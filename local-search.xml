<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GiHub Pages + Hexo ブログの爆誕</title>
    <link href="/2025/02/06/2025-02-06-post1/"/>
    <url>/2025/02/06/2025-02-06-post1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近终于能从忙碌中脱身，挤出点时间做自己的事情。遂重拾这搁置多年的项目，开辟一个属于自己的天地(博客)，将我所经历的时光铭刻于文字中，而不是任凭它们随记忆消散。随着年龄增长，人逐渐被卷入社会的漩涡，与越来越广阔的世界交织，独属于自己的时间被逐渐增加的琐事蚕食。我开始意识到，若非难事，真正想做的事、珍视的事情，最适时机就是当下。无论多么忙碌，我们都需要保留一份独属于自己的闲暇，仔细耕耘内心的处女地，而非任凭琐事侵染，最终只留得一事无成的感慨。</p><p>碎碎念就到此为止 ......简单介绍对这个博客的想法。如前面所说，我建立这个博客的初衷就是记录日常所思所得，记录和谈论与我一切感兴趣领域：动漫、音乐、文学、物理、化学相关的话题。文章形式可能包括短评、技术日志、学习笔记、(碎碎念)等。虽是这样规划的，等真正开始之后大概也不会拘于形式，随性而写吧(笑)。(总之能够坚持下去就足够了)</p><p>以下是参考<a href="https://fanyfull.github.io/2021/10/16/Github-Hexo-%E7%9C%9F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA-GitHub-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/">FanyFull's Blog</a>的搭建流程。</p><h1 id="背景">背景</h1><p>简单介绍GiHub Pages + Hexo approach的背景知识。</p><p>GitHubPages是GitHub提供的一项服务，可将托管在GitHub上一个仓库<code>username.github.io</code>中的html、css、js代码渲染成静态页面。每个GiHub账户只能有一个这样的仓库(仓库的可见性需设为public)。上传博客内容后，可通过域名https://www.username.github.io访问博客，这里<code>username</code>是自己的github用户名。使用GitHubPages搭建博客有诸多优点，如免费方便、数据绝对安全且能恢复历史版本、可灵活设计博客外观等。</p><h1 id="准备工作">准备工作</h1><ul><li>注册GitHub账号</li><li>安装git for windows (或其他git客户端)，并进行基本配置</li><li>安装node.js、npm</li></ul><h2 id="配置git-for-windows">配置Git for Windows</h2><p>已经有GibHub账号，这里简单记录git for windows的配置</p><p>打开Git Bash，设置用户名和邮箱。在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-comment"># user_name 填入 GitHub 用户名</span><br>$ git config --global user.email <span class="hljs-string">&quot;user_email&quot;</span> <span class="hljs-comment"># user_email 填入 GitHub 注册的邮箱 </span><br></code></pre></td></tr></table></figure><p>配置 SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;user.email&quot;</span> <span class="hljs-comment"># user.email 为GitHub 上注册的邮箱</span><br></code></pre></td></tr></table></figure><p>默认不需要设置密码。可以选择在指定的路径下产生ssh密钥：私钥id_rsa和公钥id_rsa.pub。将id_rsa.pub内容全部复制，打开GitHub_Settings_keys界面，新建<code>new SSH key</code></p><p><img src="/2025/02/06/2025-02-06-post1/image-20250205201400726.png" alt="image-20250205201400726" style="zoom:50%;"></p><p>标题任拟，将id_rsa.pub的内容复制到Key一栏，点击<code>Add SSH key</code>。通过ssh连接GiHub仓库需要<code>C:\Users\username\.ssh</code>路径下存有私钥文件id_rsa。用以下命令检测能否成功连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>参考<a href="https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/">这篇文章</a>设置代理：</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250205194742381.png" alt="image-20250205194742381" style="zoom:50%;"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;http://127.0.0.1:7890&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;https://127.0.0.1:7890&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="安装node.js">安装node.js</h2><p>进入<a href="https://nodejs.org/en/">官网</a>下载windows版本，安装时勾选所有组件，并将其添加到系统环境变量</p><p>检验安装</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">node -v<br>npm -v<br></code></pre></td></tr></table></figure><h1 id="基于hexo框架搭建博客">基于Hexo框架搭建博客</h1><blockquote><p>官方文档： https://hexo.io/zh-cn/docs/</p></blockquote><p>“Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。”</p><p>GitHub：https://github.com/hexojs/hexo</p><p>Hexo 使用 Markdown语法解析存放在本地的文章内容，生成相应的html、css、js文件。 Github Pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，有了Hexo就可以在更新文章后快速批量生成相关页面，再将有改动的页面提交到Github，更新博客。这样大大节省我们的精力，使我们能够集中于文章的撰写。</p><h2 id="本文使用环境">本文使用环境</h2><ul><li>windows 10</li><li>node.js version — v22.13.1</li><li>npm ——v10.9.2</li><li>git version —2.42.0.windows.2</li></ul><h2 id="安装和初始化">安装和初始化</h2><p>git bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli <span class="hljs-comment"># 此命令完成对 hexo 的安装</span><br></code></pre></td></tr></table></figure><p>安装完成后，在本地新建文件夹(E:)存放博客的代码。这个文件夹将用于存放博客所有内容和素材，博客所有操作都在其中完成。</p><p>进入新建博客目录，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init <span class="hljs-comment"># hexo 在本地博客目录的初始化</span><br></code></pre></td></tr></table></figure><p>产生以下文件夹</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250205204806684.png" alt="image-20250205204806684" style="zoom:50%;"></p><h2 id="生成静态文件">生成静态文件</h2><p>Git bash输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g  <span class="hljs-comment">#生成静态文件</span><br></code></pre></td></tr></table></figure><p>然后Hexo就会在public文件夹中生成相关html、js、css文件，待提交到<code>username.github.io</code>仓库中，渲染成网页。下面的index.html就是Hexo提供的HellowWorld模板。</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250205204745104.png" alt="image-20250205204745104" style="zoom:50%;"></p><h2 id="本地预览">本地预览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s <span class="hljs-comment">#开启本地预览</span><br></code></pre></td></tr></table></figure><p>通过本地预览可以实时查看博客的渲染效果。打开浏览器访问http://localhost:4000/即可查看内容，<code>Ctrl+C</code>停止本地预览。</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250205205656259.png" alt="image-20250205205656259" style="zoom:50%;"></p><h2 id="上传到github">上传到Github</h2><p>首先安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save <span class="hljs-comment"># 安装部署插件</span><br></code></pre></td></tr></table></figure><p>Hexo有两种_config.yml文件，一种是根目录下的全局配置文件(站点配置文件)，另一种是各个主题下的主题配置文件。配置文件的参数可以在<a href="https://hexo.io/zh-cn/docs/configuration">此处</a>查询。我们先配置站点配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:chem1912/chem1912.github.io.git</span> <span class="hljs-comment">#(graminilune)</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>在Git bash中输入以下命令，部署到Github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><p>打开https://username.github.io/</p><h2 id="更改主题">更改主题</h2><p>以常用主题NexT为例展示如何更换主题。</p><blockquote><p>官方文档 https://theme-next.iissnan.com/</p></blockquote><p>克隆next主题文件夹到站点目录的themes文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next<br></code></pre></td></tr></table></figure><p>打开站点配置文件，在Extensions段设置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure><p>切换主题之前使用hexo clean，然后hexo g，hexo s</p><p>可在NexT的主题配置文件中切换主题风格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Schemes</span><br>scheme: Muse<br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br><span class="hljs-comment">#scheme: Gemini</span><br><br></code></pre></td></tr></table></figure><p>其他主题：</p><ul><li>fluid主题 https://fluid-dev.github.io/hexo-fluid-docs/</li><li>ocean主题https://github.com/zhwangart/hexo-theme-ocean?tab=readme-ov-file</li></ul><h2 id="渲染公式问题">渲染公式问题</h2><blockquote><p><a href="https://pku-zyf.github.io/formula/">Hexo渲染数学公式：配置方法与原理浅释</a></p><p><a href="https://stardustorr.github.io/2024/11/09/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/Hexo%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3/">Hexo中数学公式渲染失败的解决</a></p><p><a href="https://www.lingzhicheng.cn/2021/08/26/NunjucksErrors/">NunjucksErrors</a></p><p><a href="https://runninggump.github.io/2018/12/05/%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E5%9C%A8hexo%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/">成功解决在hexo中无法显示数学公式的问题</a></p></blockquote><h4 id="采用mathjax渲染公式">采用mathjax渲染公式</h4><p>需安装支持mathjax的渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure><p>在全局配置文件加入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">&#x27;mathjax&#x27;</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-attr">src:</span> <span class="hljs-string">custom_mathjax_source</span><br></code></pre></td></tr></table></figure><p>next的主题配置文件中加入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="hljs-attr">mathjax:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># See: https://mhchem.github.io/MathJax-mhchem/</span><br>  <span class="hljs-attr">mhchem:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">cdn:</span> <span class="hljs-string">https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></code></pre></td></tr></table></figure><p>如果仍然渲染失败，可以尝试在md文件开头yml部分加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="连续花括号问题">连续花括号问题</h4><p>过于复杂的公式仍然容易解析失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Nunjucks Error: _posts/正则系综与恒温动力学.md [Line 13, Column 35] expected variable end<br></code></pre></td></tr></table></figure><p>此时需要对公式格式微调。一个例子是，以下公式中两个连续的花括号会使得渲染失败：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>\hat H=\frac&#123;&#123;\bf p<span class="hljs-emphasis">_i&#125;^2&#125;&#123;2m_</span>i&#125;<br>$$<br></code></pre></td></tr></table></figure><p>需在花括号之间加入空格或字符：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>\hat H=\frac&#123; &#123;\bf p<span class="hljs-emphasis">_i&#125;^2&#125;&#123;2m_</span>i&#125;<br>$$<br></code></pre></td></tr></table></figure><h4 id="狄拉克符号问题">狄拉克符号问题</h4><p>发现量子力学中常用的Dirac符号无法正常渲染。在Latex中书写狄拉克符号可以用：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <br><span class="hljs-keyword">\langle</span> <span class="hljs-keyword">\Psi</span> | <span class="hljs-keyword">\Psi</span> <span class="hljs-keyword">\rangle</span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>或<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\lang</span> <span class="hljs-keyword">\Psi</span> | <span class="hljs-keyword">\Psi</span> <span class="hljs-keyword">\rang</span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>显示结果为 <span class="math display">\[\langle \Psi | \Psi \rangle\]</span>但mathjax似乎无法正确识别、。另一种方式需要physics宏包，采用的mathjax源默认有这个宏包，因而可行：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\bra</span>&#123;<span class="hljs-keyword">\Psi</span>&#125;<span class="hljs-keyword">\ket</span>&#123;<span class="hljs-keyword">\Psi</span>&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>显示结果为 <span class="math display">\[\bra{\Psi}{}\ket{\Psi}\]</span> 如果要严谨点，这里应该用内积的形式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\ip</span>&#123;<span class="hljs-keyword">\Psi</span>&#125;&#123;<span class="hljs-keyword">\Psi</span>&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>但Hexo无法渲染。</p><p>期望值，需要这样书写：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\left</span>&lt;<span class="hljs-keyword">\hat</span> O<span class="hljs-keyword">\right</span>&gt;<br></code></pre></td></tr></table></figure><p><span class="math display">\[\left&lt;\hat O\right&gt;\]</span></p><p>这是physics宏包的<a href="https://www.latexstudio.net/index.php/index/details/index/mid/1617.html">手册</a></p><h4 id="公式换行问题">公式换行问题</h4><p>最初用"\\"简单分隔Latex公式各行的方式，Hexo渲染出来没有换行。简单有效的解决办法是采用对齐符，如：<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;align&#125;<span class="hljs-keyword">\quad</span> <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i&#125;p<span class="hljs-built_in">_</span>i-1<span class="hljs-built_in">&amp;</span>=0<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i&#125;p<span class="hljs-built_in">_</span>i&#123;<span class="hljs-keyword">\cal</span> E<span class="hljs-built_in">_</span>i&#125;-U<span class="hljs-built_in">&amp;</span>=0 <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i&#125;p<span class="hljs-built_in">_</span>i&#123;<span class="hljs-keyword">\cal</span> N<span class="hljs-built_in">_</span>i&#125;-N<span class="hljs-built_in">&amp;</span>=0 <span class="hljs-keyword">\end</span>&#123;align&#125;<span class="hljs-keyword">\tag</span>&#123;1.39&#125; <br></code></pre></td></tr></table></figure></p><p>用"&amp;"指定对齐的位置。渲染效果为 <span class="math display">\[\begin{align}\quad \sum_{i}p_i-1&amp;=0\\\sum_{i}p_i{\cal E_i}-U&amp;=0 \\\sum_{i}p_i{\cal N_i}-N&amp;=0 \end{align}\tag{1.39}\]</span>总结来说，用markdown书写博文需要良好的编辑习惯，能传达同样内容的前提下采用最简洁方便方式呈现，公式只需展示核心的，这样能大大节省调整格式和排版的时间。</p><h2 id="图床配置">图床配置</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/319679704">搭建一个免费图床！彻底解决博客文章中图片存储问题！</a></p></blockquote><h3 id="新建github仓库并生成token">新建GitHub仓库并生成Token</h3><p>在GitHub上新建一个仓库blog_picture用于存储博客图片。</p><p>在账户全局设置处找到Developersettings，点击进入设置Token（注意需要时classic token）：</p><figure><img src="/2025/02/06/2025-02-06-post1/image-20250206143306923.png" alt="image-20250206143306923"><figcaption aria-hidden="true">image-20250206143306923</figcaption></figure><p>勾选user、workflow、write:packages、admin:org。</p><p>点击Generatetoken即可生成token。生成的token只会在第一次显示，需要及时保存。</p><h3 id="picgo配置github图床">PicGo配置GitHub图床</h3><p>PicGo是一个用于快速上传图片并获取图片URL链接的工具。可在<a href="https://github.com/Molunerfinn/PicGo/releases">此处</a>下载PicGo，使用指南在<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">这里</a>。</p><p>安装好PicGo后可进一步配置。</p><p>首先可自定义快捷键，“Windows中快捷上传的快捷键是Ctrl+Shift+P，点击PicoGo 左侧栏的 PicGo设置和修改快捷键设置，可以按自己喜好修改快捷键。此外，PicGo有快速截图并上传的功能，在插件设置中搜索quick-capture，然后进行安装，默认的快捷键是Ctrl+Shift+0，也可以进行修改。”</p><p>另外可在设置内开启“上传前重命名”，使得在PicGo上传图片前弹出一个窗口让我们重命名图片。</p><p>设置GiHub图床：</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250206114639973.png" alt="image-20250206114639973" style="zoom:33%;"></p><h3 id="typora配置picgo">Typora配置PicGo</h3><p><img src="/2025/02/06/2025-02-06-post1/image-20250206134459006.png" alt="image-20250206134459006" style="zoom: 33%;"></p><p>点击<code>验证图片上传选项</code>，如下图所示则为验证成功</p><p><img src="/2025/02/06/2025-02-06-post1/image-20250206115146219.png" alt="image-20250206115146219" style="zoom: 33%;"></p><h3 id="其他方案">其他方案</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/443980981">hexo-asset-img |Hexo 本地图片插件: 转换 图片相对路径 为 asset_img</a></p></blockquote><p>可以使用插件hexo-asset-image</p><p>首先安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>打开根目录下的<code>_config.yml</code>配置文件，将以下字段设为true</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>新建md文件时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;blog_name&#x27;</span> <span class="hljs-comment"># blog_name填入文章名字</span><br></code></pre></td></tr></table></figure><p>会同时创建与该文件名同名的文件夹，同时存放在<code>source/_post/</code>目录下。</p><p>文章的图片资源存放在该目录下，使用<code>Markdown</code>语法就可以链接到图片。</p><h1 id="结语">结语</h1><p>基于GiHub Pages + Hexo + PicGo + Typora搭建了博文写作的工作流，之后就是写作时间了。Enjoy Writing!</p>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/05/hello-world/"/>
    <url>/2025/02/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Molecular Dynamics in NVE ensemble</title>
    <link href="/2024/12/25/nve-md/"/>
    <url>/2024/12/25/nve-md/</url>
    
    <content type="html"><![CDATA[<h2 id="热力学回顾">热力学回顾</h2><p>热力学基本方程 <span class="math display">\[dE=\delta Q+\delta W=TdS-pdV+\mu dN\]</span> 特性函数 <span class="math display">\[S(N,V,E)=k_Bln \Omega(N,V,E)\]</span></p><p><span class="math display">\[dS=\frac{1}{T}dE-\frac{p}{T}dV+\frac{\mu}{T}dN\]</span></p><p>N决定相空间的维度。V与边界条件相关，从量子力学来看，V与能级间距关联，从而影响态密度<span class="math inline">\(\Omega\)</span>。微正则系综的微观态分布于等能面<span class="math inline">\(\hat H({\bf p,q})=E\)</span>上，概率分布为均匀分布。 配分函数即态密度(Density ofState)是正则配分函数的拉普拉斯变换(Laplace Transformation) <span class="math display">\[\Omega(N,V,E) = \int_{E&lt;\hat H({\bf p,q})&lt;E+\Delta}\frac{d\Gamma}{h^{3N}N!}\delta (\hat H({\bf p,q})-E)\]</span></p><p><span class="math display">\[P({\bf p,q})=\frac{\delta(\hat H({\bf p,q})-E)}{\Omega(N,V,E)}\]</span></p><p>可以用δ函数的性质证明位力定理(Virial theorem)，较为繁琐。 <span class="math display">\[&lt;x_i\frac{\partial \hat H}{\partial x_j}&gt;=k_BT\delta_{ij}\]</span></p><h2 id="运动方程的积分算法">运动方程的积分算法</h2><p>分子动力学的核心三要素是和运动方程积分算法、势函数模型、能量与力的计算。经典力学运动方程的积分算法有许多，但并不是所有的算法都具有时间可逆性和辛性质（symplecticproperty）。时间可逆性即为时间反演可逆性，是说在某一时刻使时间轴反向，速度方向反转，则动力学系统会沿着原先的轨迹反向演化。例如我们令$t'=-t $，则 <span class="math inline">\(\frac{d r}{d t}&#39;=-\frac{dr}{d t}\)</span>, <span class="math inline">\(\frac{d^2 r}{dt&#39;^2}=\frac{d^2 r}{d t}\)</span>,牛顿运动定律形式仍为 <span class="math inline">\(F=m\frac{d^2 r}{dt&#39;^2}\)</span>，这就意味着方程的时间可逆性。辛性质是说：如果将Hamiltonian方程写成 <span class="math display">\[\dot x=M\frac{\partial \hat{H}}{\partial x}\]</span></p><p>其中 x 是相空间位矢，M是以下矩阵： <span class="math display">\[M=\begin{pmatrix} 0 &amp; -I \\ I &amp; 0 \end{pmatrix}\\\]</span> 其中 <span class="math inline">\(I\)</span>是3N×3N的单位矩阵，则对Jacobian矩阵(<span class="math inline">\(J_{k,l}=\frac{\partial x^k_t}{\partialx^l_0}\)</span>): <span class="math display">\[M=J^TMJ\]</span> 这意味着Jacobian行列式 <span class="math inline">\(|J|=1\)</span>，相空间体积元守恒。这种性质确保了辛算法的积分误差有界，使得算法具有较好的数值稳定性，尤其是确保较好的能量守恒性。事实上存在对应于辛算法的依赖于时间步长<span class="math inline">\(\Delta t\)</span>的Hamitolnian，在轨迹推进过程中该Hamitolnian精确守恒，步长较小时计算的能量与真实的能量偏离有限。</p><p>以下我们展示三种常用的时间可逆、具有辛性质的积分算法，并与不可逆的向前欧拉算法比较。我们首先基于Taylor展开推导这些算法的表达式。</p><h3 id="verlet-算法">1. Verlet 算法</h3><p><span class="math display">\[{\bf r_i}(t+\Delta t)={\bf r_i}(t)+{\bf v_i}(t)\Delta t+\frac{ {\bfF_i}(t)}{2m_i}{\Delta t}^2+\frac{ {\bf{r_i}&#39;&#39;&#39;}(t)}{6}{\Delta t}^3+O({\Delta t}^4)\]</span></p><p><span class="math display">\[{\bf r_i}(t-\Delta t)={\bf r_i}(t)-{\bf v_i}(t)\Delta t+\frac{ {\bfF_i}(t)}{2m_i}{\Delta t}^2-\frac{ {\bf{r_i}&#39;&#39;&#39;}(t)}{6}{\Delta t}^3+O({\Delta t}^4)\]</span></p><p>两式相加，并移项可得 <span class="math display">\[{\bf r_i}(t+\Delta t)=2{\bf r_i}(t)-{\bf r_i}(t-\Delta t)+\frac{ {\bfF_i}(t)}{m_i}{\Delta t}^2+O({\Delta t}^4)\]</span> 两式相减并移项： <span class="math display">\[{\bf v_i}(t+\Delta t)=\frac{ {\bf r_i}(t+\Delta t)-{\bf r_i}(t)}{2\Deltat}+O(\Delta t^2)\]</span> 算法的实现： 1.初始化位置<span class="math inline">\(\{ {\bfr_i}(0)\}\)</span>和速度<span class="math inline">\(\{ {\bfv_i}(0)\}\)</span>。计算力<span class="math inline">\(\{ {\bfF_i}(0)\}\)</span>，然后计算<span class="math inline">\(\{ {\bfr_i}(\Delta t)\}\)</span>： <span class="math display">\[{\bf r_i}(\Delta t)={\bf r_i}(0)+{\bf v_i}(0)\Delta t+\frac{ {\bfF_i}(0)}{2m_i}{\Delta t}^2\tag{1.1}\]</span> 2.将 t 设为当前时刻。计算<span class="math inline">\(\{ {\bfF_i}(t)\}\)</span>，根据前两步的位置更新位置： <span class="math display">\[{\bf r_i}(t+\Delta t)=2{\bf r_i}(t)-{\bf r_i}(t-\Delta t)+\frac{ {\bfF_i}(t)}{m_i}{\Delta t}^2\tag{1.2}\]</span> 3.动能(速度)需另外计算： <span class="math display">\[{\bf v_i}(t+\Delta t)=\frac{ {\bf r_i}(t+\Delta t)-{\bf r_i}(t)}{2\Deltat}\tag{1.3}\]</span> 4.重复2、3步可见Verlet算法中由于三阶项相互抵消位置的局部误差为四阶，对速度则为二阶。</p><h3 id="速度verlet-velocity-verlet算法">2. 速度Verlet (VelocityVerlet)算法</h3><p><span class="math display">\[{\bf r_i}(t+\Delta t)={\bf r_i}(t)+{\bf v_i}(t)\Delta t+\frac{ {\bfF_i}(t)}{2m_i}{\Delta t}^2+O({\Delta t}^3)\]</span></p><p><span class="math display">\[{\bf r_i}(t)={\bf r_i}(t+\Delta t)-{\bf v_i}(t+\Delta t)\Delta t+\frac{{\bf F_i}(t+\Delta t)}{2m_i}{\Delta t}^2+O({\Delta t}^3)\]</span></p><p>两式相加消掉 <span class="math inline">\({\bf r_i}(t)\)</span> 得：<span class="math display">\[{\bf v_i}(t+\Delta t)={\bf v_i}(t)+\frac{\Delta t}{2m_i}[{\bfF_i}(t)+{\bf F_i}(t+\Delta t)]+O(\Delta t^2)\]</span> 相应算法为： 1.初始化位置<span class="math inline">\(\{ {\bfr_i}(0)\}\)</span>和速度<span class="math inline">\(\{ {\bfv_i}(0)\}\)</span>。</p><ol start="2" type="1"><li>将 t 设为当前时刻。计算力<span class="math inline">\(\{ {\bfF_i}(0)\}\)</span>，然后根据式(1.1)更新位置。 3.计算 <span class="math inline">\({t+\Delta t}\)</span> 时刻的力。 4.更新速度：</li></ol><p><span class="math display">\[{\bf v_i}(t+\Delta t)={\bf v_i}(t)+\frac{\Delta t}{2m_i}[{\bfF_i}(t)+{\bf F_i}(t+\Delta t)]\tag{2.1}\]</span></p><ol start="5" type="1"><li>重复2,3,4步。</li></ol><h3 id="蛙跳法-leap-frog算法">3. 蛙跳法 (Leap Frog)算法</h3><p><img src="/2024/12/25/nve-md/蛙跳法示意图.png" alt="image-20240211004856825">蛙跳法的特点在于，位置和速度的更新点总是间隔 <span class="math inline">\(1/2 \Deltat\)</span>，形成在时间轴上位置和速度的轨迹相互交错。我们可以先更新半步速度：<span class="math display">\[{\bf v_i}(\frac{1}{2}\Delta t)={\bf v_i}(0)+{\bf F_i}(0)\frac{\Deltat}{2m_i}\tag{3.1}\]</span> 令t为当前时刻，交替更新位置和速度： <span class="math display">\[{\bf r_i}(t+\Delta t)={\bf r_i}(t)+{\bf v_i}(t+\frac{\Delta t}{2})\Deltat\tag{3.2}\]</span></p><p><span class="math display">\[{\bf v_i}(t+\frac{3}{2}\Delta t)={\bf v_i}(t+\frac{\Delta t}{2})+{\bfF_i}(t+\Delta t)\frac{\Delta t}{m_i}\tag{3.3}\]</span></p><p>在没有温度和压强耦合的情况下，给定相同的起始点，蛙跳法与速度Verlet方法产生相同的轨迹，它们都是位置的三阶算法。如果给定相同的初始坐标，并用相同的一组速度初始化Verlet算法的<span class="math inline">\(\{ {\bf v}(0)\}\)</span>和蛙跳法的<span class="math inline">\(\{ {\bf v}(-\frac{\Deltat}{2})\}\)</span>，则它们的轨迹相同。</p><h3 id="向前euler算法">4. 向前Euler算法</h3><p>将微分方程 <span class="math inline">\({\bf \dot r_i}=\bfv_i\)</span> 和 <span class="math inline">\({\bf \dot v_i}=\frac{\bfF_i}{m_i}\)</span>分别展开到一阶： <span class="math display">\[{\bf r_i}(t+\Delta t)={\bf r_i}(t)+{\bf v_i}(t)\Delta t\tag{4.1}\]</span></p><p><span class="math display">\[{\bf v_i}(t+\Delta t)={\bf v_i}(t)+\frac{\Delta t}{m_i}{\bfF_i}(t)\tag{4.2}\]</span></p><p>该算法对位置是二阶，对速度是一阶。从 <span class="math inline">\(t+\Delta t\)</span> 时刻后退一步，得： <span class="math display">\[{\bf r_i&#39;}(t)={\bf r_i}(t+\Delta t)-{\bf v_i}(t+\Delta t)\Delta t\\=r_i(t)+[{\bf v_i}(t)-{\bf v_i}(t+\Delta t)]\Delta\\=r_i(t)-\frac{\Delta t}{m_i}{\bf F_i}(t)\]</span>可见前向Euler算法不具有时间可逆性。一维体系单时间步的演化的Jacobian矩阵为：<span class="math display">\[J=\begin{pmatrix} \frac{\partial r_{t+\Delta t}}{\partial r_t} &amp;\frac{\partial r_{t+\Delta t}}{\partial p_t} \\ \frac{\partialp_{t+\Delta t}}{\partial r_t} &amp; \frac{\partial p_{t+\Deltat}}{\partial p_t} \end{pmatrix}\\=\begin{pmatrix} 1 &amp; \frac{\Delta t}{m} \\ \Delta t \frac{d F}{dr}|_{r=r(t)} &amp; 1 \end{pmatrix}\\\]</span> 所以 <span class="math display">\[|J|=1-\frac{\Delta t^2}{m} \frac{d F}{d r}|_{r=r(t)}\neq 1\]</span> 前向Eular算法也不具有辛结构。</p><h2 id="利用经典传播子classical-propagator导出积分算法">利用经典传播子(ClassicalPropagator)导出积分算法</h2><p>考虑经典物理量 a，表达为相空间坐标的函数：<span class="math inline">\(a({\bf x}(t))\)</span>，则其关于时间的全导数为：<span class="math display">\[\frac{d a}{d t}=\sum_{\alpha=1}^{3N}(\frac{\partial a}{\partialq_\alpha}\dot q_\alpha+\frac{\partial a}{\partial p_\alpha}\dotp_\alpha)\\=\sum_{\alpha=1}^{3N}(\frac{\partial \hat H}{\partialp_\alpha}\frac{\partial a}{\partial q_\alpha}-\frac{\partial \hatH}{\partial q_\alpha}\frac{\partial a}{\partial p_\alpha})\]</span> 我们定义Lionville算符 <span class="math inline">\(i\hatL\)</span>： <span class="math display">\[i\hat L=\sum_{\alpha=1}^{3N}(\frac{\partial \hat H}{\partialp_\alpha}\frac{\partial }{\partial q_\alpha}-\frac{\partial \hatH}{\partial q_\alpha}\frac{\partial }{\partial p_\alpha})\]</span> 有： <span class="math display">\[i\hat L a=\{a,\hat H\}=\frac{d a}{dt}\tag{5.1}\]</span> 以上方程的形式解为： <span class="math display">\[a(t)=e^{i\hat L t}a(0)\]</span> 对相空间位矢本身有： <span class="math display">\[{\bf x}(t)=e^{i\hat L t}{\bf x}(0) \tag{5.2}\]</span> 其中 <span class="math inline">\(e^{i\hat L t}\)</span>即为经典传播子（量子传播子为 <span class="math inline">\(e^{-\frac{i\hatHt}{\hbar}}\)</span>）。如果令时间轴反转，则动量方向反转，含动量的微分反转，使得：<span class="math display">\[i\hat L&#39;=-i\hat L\]</span></p><p><span class="math display">\[x&#39;(0)=e^{i \hat L&#39;t}x(t)=e^{-i \hat Lt}x(t)=x(0)\]</span></p><p>注：上式中的t是时间间隔，是常量。因此经典传播子对时间可逆。尽管有式(5.2)，算符对相空间位矢的解析表达式常常不能获得。我们将<span class="math inline">\(i\hat L\)</span> 拆分成 : <span class="math display">\[i\hat L_1= \sum_{\alpha=1}^{3N}\frac{\partial\hat H}{\partial p_\alpha}\frac{\partial }{\partialq_\alpha}\tag{5.3}\]</span> <span class="math display">\[i\hat L_2=-\sum_{\alpha=1}^{3N}\frac{\partial \hat H}{\partialq_\alpha}\frac{\partial }{\partial p_\alpha}\tag{5.4}\]</span>然而由于这两个算符不对易，我们无法将传播子拆分： <span class="math display">\[e^{i \hat L}\neq e^{i \hat L_1}e^{i \hat L_2}\tag{5.5}\]</span> 根据可逆Trotter定理，对任意算符 <span class="math inline">\(\hat A 、\hat B\)</span>： <span class="math display">\[e^{\hat A+\hat B}=\lim_{P \to \infty}[e^{\frac{\hat B}{2P}}e^{\frac{\hatA}{P}}e^{\frac{\hat B}{2P}}]^P\tag{5.6}\]</span> 其中 P 为正整数。如果我们令<span class="math inline">\(\Deltat=t/P\)</span>，则： <span class="math display">\[e^{i\hat Lt}=\lim_{P \to \infty}[e^{\frac{i\hat L_2 \Deltat}{2}}e^{i\hat L_1\Delta t}e^{\frac{i\hat L_2 \Delta t}{2}}]^P\]</span> 有限步数下： <span class="math display">\[e^{i\hat Lt}=[e^{\frac{i\hat L_2 \Delta t}{2}}e^{i\hat L_1\Deltat}e^{\frac{i\hat L_2 \Delta t}{2}}]^P+O(P\Delta t^3)\]</span></p><p><span class="math display">\[e^{i\hat L\Delta t}= e^{\frac{i\hat L_2 \Delta t}{2}}e^{i\hat L_1\Deltat}e^{\frac{i\hat L_2 \Delta t}{2}}+O(\Delta t^3)\tag{5.7}\]</span></p><p>上式直接对应velocityVerlet算法。让我们考虑算符的形式与作用效果。对于Hamiltonian: <span class="math display">\[\hat H=\sum_{i=1}^{N}\frac{\bf p_i^2}{2m_i}+U(\bf\{r_i\})\]</span> <span class="math display">\[i\hat L_1=\sum_{i=1}^N\frac{\bf p_i}{m_i}\frac{\partial }{\partial \bfr_i}\tag{5.8}\]</span></p><p><span class="math display">\[i\hat L_2=\sum_{i=1}^N {\bf F_i} \frac{\partial }{\partial \bfp_i}\tag{5.9}\]</span></p><p>这两个算符中求和的各项相互对易，从而它们的传播子作用效果相当于这种形式的算符：<span class="math inline">\(exp(c\frac{\partial}{\partial x})\)</span>分别作用于被操作函数上，其作用效果为： <span class="math display">\[exp(c\frac{\partial }{\partialx})f(x)=\sum_{k=0}^{\infty}\frac{c^k}{k!}\frac{\partial^k f}{\partialx^k}=f(x+c)\tag{5.10}\]</span> 因而velocityVerlet算法可表述为：1.速度(动量)更新半步 2. 位置更新整步 3.更新力，然后计算整步后的速度。写成伪代码：<img src="/2024/12/25/nve-md/伪代码.png" alt="输入图片说明" style="zoom: 33%;">可以证明这里所述的三步算法与前面的velocity Verlet算法相同。传播子的不同构造方式导致了Verlet算法、蛙跳法，原则上它们的轨迹局部误差都是三价。在前述Verlet算法的实现中，所用步长相当于这里三步法中的一半，其局部误差为四阶。但就速度和位置都更新的完整一步而言，三种算法都是三价。它们的速度误差都是时间步长的二阶。与温度与压力耦合时，更建议使用velocity Verlet算法。</p><figure><img src="/2024/12/25/nve-md/image-20250207010749536.png" alt="image-20250207010749536"><figcaption aria-hidden="true">image-20250207010749536</figcaption></figure><h2 id="速度初始化">速度初始化</h2><p>位置的初始化方式多样，选择合适的初始构型是分子模拟的重要议题，此处不讨论。正则系综、等温等压系综，粒子动量/速度的平衡态分布为Gaussian分布：<span class="math display">\[p(v_i)=\sqrt \frac{m_i}{2\pi k_BT}exp(-\frac{m_iv_i^2}{2k_BT})\tag{6.1}\]</span> 其中 <span class="math inline">\(v_i\)</span> 是分子 i其中一个Cartesian坐标对应的速度。为了初始化粒子的速度，需产生符合上述分布的随机变量。产生符合特定概率分布的样本点也是MonteCarto的核心议题。</p><blockquote><h3 id="从已知概率分布和变换关系求未知分布">从已知概率分布和变换关系求未知分布</h3><ul><li>一维： 已知随机变量X具有概率分布函数(PDF) <span class="math inline">\(f_X(x)\)</span>，设<span class="math inline">\(Y=g(X)\)</span>，在定义域内X与Y一一对应，则Y的PDF为<span class="math inline">\(f_Y(y)=f_X(g^{-1}(y))\cdot|\frac{dx}{dy}|\)</span>。证明如下 如果g(X)单调递增，则Y的累积分布函数CDF为</li></ul><p><span class="math display">\[F_Y(y)=P(Y\leqslant y)=P(g(X)\leqslant y)=P(X\leqslantg^{-1}(y))=F_X(g^{-1}(y))\]</span></p><p>如果g(X)单调递减，则 <span class="math display">\[F_Y(y)=P(Y\leqslant y)=P(g(X)\leqslant y)=P(X\geqslantg^{-1}(y))=1-F_X(g^{-1}(y))\]</span> 则 <span class="math display">\[f_Y(y)=\pm\frac{dF_X[g^{-1}(y)]}{dy}=f_X(g^{-1}(y))\cdot|\frac{dx}{dy}|\tag{6.2}\]</span></p><ul><li>二维及高维： 设随机变量组<span class="math inline">\((X_1,X_2)\)</span>具有联合PDF <span class="math inline">\(f_{X_1X_2}(x_1,x_2)\)</span>。通过可逆变换得到<span class="math inline">\((Y_1,Y_2)\)</span>，在一定区域内<span class="math inline">\((X_1,X_2)\)</span>与<span class="math inline">\((Y_1,Y_2)\)</span>一一对应，其逆变换为：</li></ul><p><span class="math display">\[\begin{cases} X_1=w_1(Y_1,Y_2)\\X_2=w_2(Y_1,Y_2)\end{cases}\]</span></p><p>假设<span class="math inline">\((X_1,X_2)\)</span>空间内任意区域<span class="math inline">\(\Gamma_X\)</span>对应于<span class="math inline">\((Y_1,Y_2)\)</span>空间内的<span class="math inline">\(\Gamma_Y\)</span>，则<span class="math inline">\(P(\Gamma_X)=P(\Gamma_Y)\)</span>，即 <span class="math display">\[\iint_{\Gamma_Y}f_{Y_1Y_2} (y_1,y_2)dy_1dy_2=\iint_{\Gamma_X}f_{X_1X_2}(x_1,x_2)dx_1dx_2\\=\iint_{\Gamma_Y}f_{X_1X_2}(w_1(y_1,y_2),w_2(y_1,y_2))|J|dy_1dy_2\]</span> 则 <span class="math display">\[f_{Y_1Y_2}(y_1,y_2)=f_{X_1X_2} (w_1(y_1,y_2),w_2(y_1,y_2))|J|\tag{6.3}\]</span>其中|J|是Jacobian <span class="math display">\[|J|=\begin{vmatrix} \frac{\partial x_1}{\partial y_1} &amp;\frac{\partial x_1}{\partial y_2} \\\\ \frac{\partial x_2}{\partial y_1}&amp; \frac{\partial x_2}{\partial y_2} \end{vmatrix}\]</span></p><ul><li>产生符合特定分布的随机变量计算机通常能产生满足均匀分布的伪随机数。通过一定的变换，可将其转换满足任意概率分布的随机变量。如果<span class="math inline">\(\zeta\)</span> 满足[0,1]上均匀分布，<span class="math inline">\(p(x)\)</span> 是目标概率分布，其CDF为<span class="math inline">\(F(x)\)</span>。只要令<span class="math inline">\(F(X)=\zeta\)</span>，即<span class="math inline">\(X=F^{-1}(\zeta)\)</span>，就可使 <span class="math inline">\(X\)</span> 具有目标概率分布 <span class="math inline">\(p(x)\)</span>。</li></ul><p>麻烦的是，Gaussian分布的CDF没有解析形式。而Box-Millersampling提供了相对简单的获得Gaussian分布获取方式。考虑两个满足Gaussian分布的独立变量<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>，其 PDF 为 <span class="math inline">\(f_{X,Y}(x,y)=\frac{1}{2\pi\sigma^2}exp(-\frac{x^2+y^2}{2\sigma^2})\)</span>。其CDF为 <span class="math display">\[F(x&#39;,y&#39;)=\frac{1}{2\pi\sigma^2}\int_{-\infty}^{x&#39;} \int_{-\infty}^{y&#39;}exp(-\frac{x^2+y^2}{2\sigma^2})dxdy\\=\frac{1}{2\pi \sigma^2}\int_{0}^{\Phi&#39;}d\Phi  \int_{0}^{R&#39;}R\,exp(-\frac{R^2}{2\sigma^2})dR\\=\frac{\Phi}{2\pi}&#39;[1-exp(-\frac{R&#39;^2}{2\sigma^2})]\]</span>这里做了变换：</p></blockquote><p><span class="math display">\[\begin{cases} X=R\,cos\Phi\\ Y=R\,sin \Phi\end{cases}\]</span></p><p>上式最后一行可看做两个独立随机变量之CDF的乘积，令这两个随机变量为：<span class="math display">\[\begin{cases} \zeta_1=\Phi/2\pi\\\zeta_2=1-exp(-\frac{R^2}{2\sigma^2})\end{cases}\]</span> 这两个变量都是[0,1]上均匀分布的随机数，从而： <span class="math display">\[\begin{cases} X=\sigma \sqrt {-2ln(1-\zeta_2)}\,cos(2\pi\zeta_1)\\Y=\sigma \sqrt {-2ln(1-\zeta_2)}\,sin(2\pi\zeta_1)\end{cases} \tag{6.4}\]</span> 对于速度分布 <span class="math inline">\(\sigma=\sqrt{\frac{k_BT}{m_i}}\)</span>.</p><h2 id="模型体系">模型体系</h2><h3 id="一维简谐振子">一维简谐振子</h3><p><span class="math display">\[\hat H=\frac{p^2}{2m}+\frac{1}{2}m\omega^2x^2\tag{7.1}\]</span></p><p>Hamiltonian 正则方程为 <span class="math display">\[\begin{cases}\dot p=-m\omega^2x\\\dot x=p/m\end{cases}\tag{7.2}\]</span> 解之得： <span class="math display">\[\begin{cases}x(t)=x(0)cos(\omega t)+\frac{p(0)}{m\omega}sin(\omegat)\\p(t)=-m\omega \cdot x(0)sin(\omega t)+p(0)cos(\omega t)\end{cases}\tag{7.3}\]</span> 相空间轨迹为一个椭圆： <span class="math display">\[\frac{[p(t)]^2}{2m}+\frac{1}{2}m\omega^2[x(t)]^2=E\tag{7.4}\]</span> 总能 <span class="math display">\[E=\frac{[p(0)]^2}{2m}+\frac{1}{2}m\omega^2[x(0)]^2\]</span>代码实现（输入模型参数和初始坐标、动量，模拟步数和步长。输出轨迹、对应点的动量和能量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#简谐振子</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> cos,sin,sqrt<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">oscillator</span>(<span class="hljs-params">x0,p0,n,dt,m,omega</span>):<br>    trj=np.zeros([<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>])<br>    e0=p0*p0/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x0*x0<br>    trj[:,<span class="hljs-number">0</span>]=[x0,p0,e0]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        t=i*dt<br>        x=x0*cos(omega*t)+p0/m/omega*sin(omega*t)<br>        p=-m*omega*x0*sin(omega*t)+p0*cos(omega*t)<br>        e=p*p/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x*x<br>        trj[:,i]=[x,p,e]<br>    <span class="hljs-keyword">return</span> trj<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int_euler</span>(<span class="hljs-params">x0,p0,n,dt,m,omega</span>):<br>    trj=np.zeros([<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>])<br>    e0=p0*p0/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x0*x0<br>    x=x0<br>    p=p0<br>    trj[:,<span class="hljs-number">0</span>]=[x0,p0,e0]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        f=-m*omega*omega*x<br>        x=x+p/m*dt<br>        p=p+f*dt<br>        e=p*p/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x*x<br>        trj[:,i]=[x,p,e]<br>    <span class="hljs-keyword">return</span> trj<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int_verlet</span>(<span class="hljs-params">x0,p0,n,dt,m,omega</span>):<br>    trj=np.zeros([<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>])<br>    e0=p0*p0/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x0*x0<br>    x=x0<br>    p=p0<br>    trj[:,<span class="hljs-number">0</span>]=[x0,p0,e0]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        x=x+p/m*dt/<span class="hljs-number">2</span><br>        f=-m*omega*omega*x<br>        p=p+f*dt<br>        x=x+p/m*dt/<span class="hljs-number">2</span><br>        e=p*p/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x*x<br>        trj[:,i]=[x,p,e]<br>    <span class="hljs-keyword">return</span> trj<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int_vverlet</span>(<span class="hljs-params">x0,p0,n,dt,m,omega</span>):<br>    trj=np.zeros([<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>])<br>    e0=p0*p0/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x0*x0<br>    x=x0<br>    p=p0<br>    f=-m*omega*omega*x<br>    trj[:,<span class="hljs-number">0</span>]=[x0,p0,e0]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        p=p+f*dt/<span class="hljs-number">2</span><br>        x=x+p/m*dt<br>        f=-m*omega*omega*x<br>        p=p+f*dt/<span class="hljs-number">2</span><br>        e=p*p/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x*x<br>        trj[:,i]=[x,p,e]<br>    <span class="hljs-keyword">return</span> trj<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int_leapfrog</span>(<span class="hljs-params">x0,p0,n,dt,m,omega</span>):<br>    <span class="hljs-comment">#速度(动量)从0.5dt时刻算起，n是位置步的数目</span><br>    trj=np.zeros([<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>])<br>    x=x0<br>    f=-m*omega*omega*x<br>    p=p0+f*dt/<span class="hljs-number">2</span><br>    e0=p0*p0/<span class="hljs-number">2</span>/m+<span class="hljs-number">0.5</span>*m*omega*omega*x0*x0<br>    trj[:,<span class="hljs-number">0</span>]=[x,p,e0]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        k0=p*p/<span class="hljs-number">2</span>/m<br>        x=x+p/m*dt<br>        f=-m*omega*omega*x<br>        p=p+f*dt<br>        <span class="hljs-comment">#t时刻的动能用t-dt/2和t+dt/2的平均得到</span><br>        kn=(p*p/<span class="hljs-number">2</span>/m+k0)/<span class="hljs-number">2</span><br>        e=kn+<span class="hljs-number">0.5</span>*m*omega*omega*x*x<br>        <span class="hljs-comment">#动量所对应的时刻与位置的时刻错开</span><br>        trj[:,i]=[x,p,e]<br>    <span class="hljs-keyword">return</span> trj<br></code></pre></td></tr></table></figure><p>结果：<img src="/2024/12/25/nve-md/微正则系综MD.png" alt="微正则系综MD" style="zoom:33%;"></p><p><img src="/2024/12/25/nve-md/微正则系综MD2.png" style="zoom:33%;"></p><p><img src="/2024/12/25/nve-md/微正则系综MD3.png" alt="微正则系综MD3" style="zoom: 67%;"></p><p>可见在当前步长下，向前Euler算法不能保证能量守恒，数值稳定性不佳，模拟过程中相轨迹发散（能量增大)。相比之下辛算法的能量守恒性很好。</p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Mark E. Tuckerman. (2010). <em>Statistical Mechanics: Theory andMolecular Simulation</em>. Oxford: Oxford University Press.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Science</category>
      
      <category>Computational Chemistry</category>
      
      <category>Molecular Dynamics</category>
      
      <category>Statistical Mechanics</category>
      
      <category>Classical Mechanics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Molecular Dynamics</tag>
      
      <tag>Statistical Mechanics</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basis of Statistical Mechanics in Equilibrium Ensemble</title>
    <link href="/2024/07/05/equi-statistical-basis/"/>
    <url>/2024/07/05/equi-statistical-basis/</url>
    
    <content type="html"><![CDATA[<p>一个宏观系统的具有数目庞大的自由度，可能的微观态(microstate)有许多。在通常的时间尺度下对系统进行观测，系统每一时刻都处于某个微观态，在不同的微观态之间切换，观测所得的物理量是不同微观态的时间平均：<span class="math display">\[\overline O = \frac{1}{t_0}\int_0^{t_0} O(t)dt\, = \sum_i^Nf(\mu_i)O(\mu_i). \tag{1.1}\]</span> ​如果系统处于各个微观态的概率不随时间变化，即稳态概率分布，且观测时间足够长，系统能够遍历一切可能的微观态并采样到正确的概率分布，则上述时间平均可以写成以概率为权重，对各个微观态性质的加权平均：<span class="math display">\[&lt;O&gt; = \sum_i^Np(\mu_i) O(\mu_i) \tag{1.2}.\]</span> ​为得到概率分布，想象许多个当前系统的思维副本所构成的集合——系综(ensemble)，使其成员各自独立地按相同的运动方程演化，根据大数定律，当副本数目趋向无穷(热力学极限)，就能采样到正确的稳态概率分布。如果前述各态历经(ergodicity)假设成立，我们就可以用式(1.2)的系综平均代替式(1.1)的时间平均，避免直接求解含~10<sup>23</sup>个粒子的宏观体系的运动方程，用统计的方法从微观粒子的力学性质计算宏观物理量。</p><h1 id="经典相空间classical-phase-space">经典相空间(Classical Phasespace)</h1><p>​ 在经典力学中，一个N粒子系统的微观状态可以完全由每个粒子的空间坐标<span class="math inline">\(\vec{q_i}\)</span> 和动量 <span class="math inline">\(\vec{p_i}\)</span>确定，所有可能的微观态组成6N维的相空间(phase space) <span class="math inline">\(\Gamma = \Pi_{i=1}^N\{\vec{q_i},\vec{p_i}\}\)</span>。对保守体系，相点的轨迹可由哈密顿方正则方程(canonical equations)描述：<span class="math display">\[\begin{cases} \frac{d\vec{q_i}}{dt}=\frac{\partial \hat{\calH}}{\partial \vec{p_i}}\\\frac{d\vec{p_i}}{dt}=-\frac{\partial \hat{\calH}}{\partial \vec{q_i}}\end{cases} \tag{1.3}\]</span>注意它具有时间反演对称性，即在某一时刻如果动量大小不变，方向反转，体系会演原先轨迹演化。系综可视为相空间中满足一定边界条件(BoundaryConditions)和约束(Constrains)区域内的大量点的集合，系综中的每个成员都对应于相空间中一个代表点<span class="math inline">\(\mu_i(t)\)</span>，系统处于某一点<span class="math inline">\((\mathbf{p},\mathbf{q})\)</span>附近的概率为：<span class="math display">\[\rho(\mathbf{p},\mathbf{q},t) d\Gamma= \lim_{N\to \infty}\frac{dN(\mathbf{p},\mathbf{q},t)}{N}. \tag{1.4}\]</span> 系综平均为： <span class="math display">\[&lt;O&gt;=\int\rho(\mathbf{p},\mathbf{q},t)O(\mathbf{p},\mathbf{q})d\Gamma . \tag{1.5}\]</span> 这样系统的宏观态可由相空间密度 <span class="math inline">\(\rho(t)\)</span>来描述，密度随时间的演化遵循刘维尔定理(Liouville's equation)，可由任何一对代表点所围成的体积不随时间变化来证明：<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础.png" alt="平衡态统计力学基础" style="zoom:50%;"><span class="math display">\[\frac{d\rho}{dt} = \frac{\partial \rho}{\partial t} +\sum_{a=1}^{3N}(\frac{\partial \rho}{\partialp_{\alpha}}\cdot\frac{dp_\alpha}{dt}+\frac{\partial \rho}{\partialq_\alpha}\cdot\frac{dq_\alpha}{dt}) = 0. \tag{1.6}\]</span>这说明相空间密度的行为如同不可压缩流体，若随着某一个流体质点运动，经过的区域流体密度不发生改变。也可表述为N个代表点所占据的相空间体积不随时间变化(这似乎说明系统的微观态对应于相空间内的固定体积)。引入泊松括号： <span class="math display">\[\{A, B\}=\sum_{a=1}^{3N}(\frac{\partial A}{\partialq_{\alpha}}\cdot\frac{\partial B}{\partial p_\alpha}-\frac{\partialA}{\partial p_\alpha}\cdot\frac{\partial B}{\partial q_\alpha}) =-\{B,A\}. \tag{1.7}\]</span> 根据正则方程，式(1.6)可写成： <span class="math display">\[\frac{\partial \rho}{\partial t} = -\{\rho, \hat{\cal H}\} \tag{1.8}\]</span>该方程同样具有时间反演对称性。由该方程可推出物理量的系综平均随时间的变化率为<span class="math display">\[\frac{d&lt;O&gt;}{dt}=&lt;\{O, \hat{\cal H}\}&gt; \tag{1.9}\]</span> 平衡态下系综平均不随时间变化，系综具有稳态的密度：<span class="math inline">\(\partial \rho_{eq}/\partial t=0\)</span>，则<span class="math inline">\(\{\rho_{eq}, \hat{\calH}\}=0\)</span>。该方程一个自然的解为：<span class="math inline">\(\rho_{eq}(\mathbf{p},\mathbf{q})=\rho(\hat{\calH}(\mathbf{p},\mathbf{q}))\)</span>，即 <span class="math inline">\(\rho\)</span> 显含 <span class="math inline">\(\hat{\cal H}\)</span> 且表示为只是 <span class="math inline">\(\hat{\cal H}\)</span> 的单变量函数，在恒能面 <span class="math inline">\(\hat{\cal H}(\mathbf{p},\mathbf{q})=E\)</span> 上<span class="math inline">\(\rho\)</span> 为常数 。平衡态下能量相同的微观态出现概率相同，这构成了统计力学的等概率公设(Postulateof Equal a Priori Probability)。如果相空间密度具有 <span class="math inline">\(\rho=\rho(\hat{\cal H}(\mathbf p, \mathbfq),L_1(\mathbf p,\mathbf q),L_2(\mathbf p,\mathbf q),...)\)</span>的形式，<span class="math inline">\(L_n\)</span> 是满足 <span class="math inline">\(\{L_n,\hat{\cal H}\}=0\)</span> 的守恒量，则 <span class="math inline">\(\rho\)</span> 也是稳态密度。</p><h1 id="系综理论ensemble-theory">系综理论(Ensemble Theory)</h1><h2 id="平衡态统计力学的基本假设">平衡态统计力学的基本假设</h2><ul><li>遍历假设(ergodicity): <em>物理量 <span class="math inline">\(f\)</span> 的观测值 = 长时间平均 <span class="math inline">\(\frac{1}{\Delta t}\int_0^{\Delta t}f(t)dt\)</span>= 系综平均<span class="math inline">\(&lt;f&gt;\)</span></em>。这就要求在观测时间内，系统能到达所有可能的微观态，并无偏地采样到平衡态的概率分布。对于少数体系，可证明遍历性定理(ergodictheorem)，充分长的时间内代表点可无限接近相空间内所有的可及点，然而该时间尺度远远大于通常观测的时间。实际情况下环境的微扰会大大增加系统到达各可能状态的能力。各态历经假设的合理性只能通过实验证明。</li><li>等概率公设 (Boltzmann's assumption of equal a priori equilibriumprobabilities)：<em>平衡态的孤立体系各微观状态等几率出现。在经典相空间中，等能面上的概率密度均匀分布。</em></li><li>熵(entropy)的统计定义: 孤立体系的熵为 <span class="math display">\[S=k_Bln\Omega \tag{1.10}\]</span> 其中 <span class="math inline">\(k_B\)</span>是Boltzmann常数，<span class="math inline">\(\Omega\)</span>​是体系可能的微观状态数。式(1.10)定义的熵等价于信息论中均匀概率分布的信息熵。<em>熵是无序性与信息不确定性的量度，系统内部的自发过程总是倾向使系统的熵增大</em>（满足约束条件下系综概率分布的重组亦可视为“内部自发过程”）。平衡态使熵取极大值。</li></ul><blockquote><p><strong>信息熵</strong> 考虑离散的随机变量 <span class="math inline">\(X=\{x_i\}\)</span>，每种可能输出的出现概率为 <span class="math inline">\(\{p_i\}, i=1,2,...,M.\)</span> 若进行 N次独立重复试验，结果有M<sup>N</sup>种可能的情况，如果没有任何关于试验结果的先验知识，则精确地传达试验结果需要<span class="math inline">\(Nlog_2M\)</span> bit的信息。现在知道随机变量X输出值的概率分布，如果各种输出的出现概率不均等，则实验结果的不确定性减少。当<span class="math inline">\(N\to\infty\)</span>​,可认为 N次试验中，x<sub>i</sub> 出现次数为N<sub>i</sub>=Np<sub>i</sub>。这样可能的序列数为： <span class="math display">\[\Omega=\frac{N!}{\prod_{i=1}^MN_i!} \tag{1.11}\]</span> 指定试验结果序列需要的信息量(使用Starling近似)： <span class="math display">\[log_2 {\Omega}\approx-N\sum_{i=1}^Mp_ilog_2{p_i} \quad (for \quadN\to\infty) \tag{1.12}\]</span>Shannon定理指出，这就是N趋于无穷的极限下精确传递信息所需的最少bit数。非均匀概率分布 <span class="math inline">\(log_2\Omega\)</span> 小于<span class="math inline">\(Nlog_2M\)</span>，这就说明概率分布本身携带信息，使得结果的不确定性减小，其信息量定义为：<span class="math display">\[I[\{p_i\}]=log_2M+\sum_{i=1}^Mp_ilog_2{p_i} \tag{1.13}\]</span> 除了 <span class="math inline">\(\delta\)</span> 函数分布<span class="math inline">\(p_i=\delta_{i,j}\)</span>外，其余的概率分布仍存在不确定性，需要大于1bit的信息确定试验结果，式(1.12)的量度量了这种不确定性。我们定义概率分布的信息熵为：<span class="math display">\[S=-\sum_{i=1}^Mp_ilnp_i=-&lt;lnp&gt; \tag{1.14}\]</span> <span class="math inline">\(\delta\)</span>函数分布的熵为0，而均匀分布 <span class="math inline">\(p_i=1/M\)</span>的熵取最大值<span class="math inline">\(lnM\)</span>。S是概率分布离散性的量度，是无序性和不确定性的量度。信息论的熵定义对所有系综均适用，均匀分布的情况(孤立体系)，信息熵等同于Boltzmann熵。​遍历假设使我们不必研究宏观系统的含时演化，转而研究各微观态上概率分布。平衡系统的宏观态M与相空间的概率密度函数<span class="math inline">\(\rho_M(\bf q,\bf p)\)</span>或希尔伯特空间的密度矩阵 <span class="math inline">\(\bf{\rho_M}\)</span>一一对应，只要知道后者，就能计算宏观系统的一切物理量。系综理论的核心就在于推导各种系综的概率分布函数。大致有三种方式：(1)研究与环境达到热平衡的系统，复合系统形成孤立体系 (2)最概然分布法。利用Lagrange乘子法求取满足系综约束条件并使Boltzmann熵或信息熵最大的概率分布。(3)Darwin-Fowler 鞍点法。</p></blockquote><h2 id="系统-环境法">系统-环境法</h2><blockquote><p><img src="/2024/07/05/equi-statistical-basis/clip_image002-1718866014782-1.jpg" alt="clip_image002-1718866014782-1" style="zoom:67%;"><img src="/2024/07/05/equi-statistical-basis/clip_image004-1718866014782-3.jpg" alt="clip_image004-1718866014782-3" style="zoom:67%;"><img src="/2024/07/05/equi-statistical-basis/clip_image006-1718866014782-2.jpg" alt="clip_image006-1718866014782-2" style="zoom:67%;"></p></blockquote><h2 id="最概然分布法">最概然分布法</h2><h3 id="微正则系综microcanonical-ensemble">微正则系综(MicrocanonicalEnsemble)</h3><p>​ 微正则系综对应于孤立体系，系统的粒子数 N、体积 V (广义位移x）和能量E 固定，其宏观状态即由这组参数 <span class="math inline">\((N,V,E)\)</span> 唯一确定。根据基本假设，系统处于某一微观态 <span class="math inline">\(\mu\)</span> 的概率为： <span class="math display">\[p(\mu)=\frac{\delta(\hat{\cal H}(\mu)-E)}{\Omega(N,V,E)}\tag{1.15}\]</span> 经典相空间中的密度为： <span class="math display">\[\rho(\mathbf p, \mathbf q)= \frac{\delta_\Delta(\hat{\cal H}(\mathbfp,\mathbf q)-E)}{\Omega(N,V,E)}\tag{1.16}\]</span> 其中 <span class="math inline">\(\Omega(N,V,E)\)</span>是满足边界条件和约束条件：<span class="math inline">\(E-\Delta \le\hat{\cal H}(\mathbf p,\mathbf q)\le E+\Delta\)</span>的区域体积。显然相空间体积与微观状态数对应。由于量子力学中的不确定性关系，动量p 和位置 q 不可同时精确确定。微观状态数应是与单位无关的无量纲量，而相空间体积元具有(动量×长度)<sup>3N</sup>的量纲。并考虑全同粒子的不可分辨性，相空间体积元应校正为：<span class="math display">\[d\Gamma_N=\frac{1}{h^{3N}N!}\prod_{i=1}^Nd^3\vec q_id^3\vec p_i\tag{1.17}\]</span>从信息熵的定义出发，可自然地推导出微正则系综的均匀概率分布。</p><h3 id="拉格朗日乘子法lagrange-multiplier-method">拉格朗日乘子法(LagrangeMultiplier Method)</h3><p>拉格朗日乘子法用于解决带约束条件下的优化问题，其基本思想是通过引入拉格朗日乘子，将含有n个变量、k个约束条件的约束优化问题转化为含(n+k)个变量的无约束优化问题。首先考虑只有单个等式约束的优化问题： <span class="math display">\[\begin{align} min \quad &amp;f(\mathbf x) \\s.t. \quad &amp;g(\mathbf x)=0 \quad  \end{align}\tag{1.18}\]</span> 目标是在由方程 <span class="math inline">\(g(\mathbfx)=0\)</span> 确定的 (n-1) 维曲面上寻找极值点，从几何上说，该点处 <span class="math inline">\(f(\mathbf x)\)</span>的等值面与约束曲面相切，使得沿约束曲面的任意切线方向 <span class="math inline">\(f(\mathbf x)\)</span>的方向导数都为零。约束曲面的任一点处梯度 <span class="math inline">\(\nabla g(\mathbf x)\)</span> 都与曲面正交，<span class="math inline">\(f(\mathbf x)\)</span> 的等值面上 <span class="math inline">\(\nabla f(\mathbfx)\)</span>也正交于切面。因而在最优点，此两者应当共线： <span class="math display">\[\nabla f(\mathbf x)+\lambda \nabla g(\mathbf x)=0 \tag{1.19}\]</span> 上式有n个方程，加上约束等式即可确定最优点坐标 <span class="math inline">\(\bf x^*\)</span> 和Lagrange乘子<span class="math inline">\(\lambda\)</span>。若无约束条件下的 <span class="math inline">\(f(\mathbf x)\)</span> 极值点恰在约束曲面上，则<span class="math inline">\(\nabla f(\mathbf x^*)=0\)</span>，设<span class="math inline">\(\lambda=0\)</span>，式 (1.19) 仍成立.定义Lagrange函数 <span class="math inline">\(L(\mathbfx,\lambda)=f(\mathbf x)+\lambda g(\mathbfx)\)</span>，则等式约束的极值条件写成： <span class="math display">\[\begin{align}\nabla_{\mathbf x} L(\mathbf x,\lambda)=0\Leftrightarrow\nabla f(\mathbf x)+\lambda \nabla g(\mathbf x)=0 \\\frac{\partial L(\mathbf x,\lambda)}{\partial \lambda}=0 \Leftrightarrowg(\mathbf x)=0 \quad \end{align}\tag{1.20}\]</span> 上述方法可推广到多个等式约束的情形，此时 <span class="math inline">\(\nabla f(\mathbf x)\)</span>是各个约束方程梯度的线性组合： <span class="math display">\[\begin{align}\lambda_ig_i(\mathbf x)=0 \quadi=1,2,...,k\\\nabla f(\mathbf x)+\sum_{i=1}^k\lambda_i \nabla g_i(\mathbf x)=0\end{align}\tag{1.21}\]</span>Lagrange乘子法也适用于不等式约束。考虑约束条件 <span class="math inline">\(g(\mathbf x)\le0\)</span>，最优点要么在 <span class="math inline">\(g(\mathbf x)\lt0\)</span> 的区域内，要么在边界<span class="math inline">\(g(\mathbf x)=0\)</span> 上。第一种情况可令<span class="math inline">\(\nabla f(\mathbf x)=0\)</span>，等价于<span class="math inline">\(\lambda=0\)</span>时对Lagrange函数求导。后一种情况类似等式约束的处理，但附加<span class="math inline">\(\nabla f(\mathbf x^*)\)</span> 与 <span class="math inline">\(\nabla g(\mathbf x^*)\)</span>方向相反的条件，即<span class="math inline">\(\lambda&gt;0\)</span>，否则边界附近以内的区域存在比边界上函数值更小的点，最优点不在边界上。<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础2.jpg" alt="平衡态统计力学基础2" style="zoom:50%;">对于含同时含等式和不等式约束的优化问题，Lagrange乘子法可将原始问题转化为Karush-Kuhn-Tucker条件(KKT)条件下Lagrange函数的最优化问题。KKT条件是转化后问题与原问题等价的必要条件。原问题： <span class="math display">\[\begin{align} min \quad &amp;f(\mathbf x)\\s.t.: \,\quad &amp;g_i(\mathbf x)\le0\quad i=1,...,m \\\quad\qquad &amp;h_j(\mathbf x)=0\quad j=1,...,l \end {align} \tag{1.22}\]</span> Lagrange乘子： <span class="math display">\[\begin{align}min\quad L(\mathbf x,\mathbf \lambda,\mathbf\mu)&amp;=f(\mathbf x)+\sum_{i=1}^m\lambda_ig_i(\mathbfx)+\sum_{j=1}^l\mu_jh_j(\mathbf x)\\-\nabla f(\mathbf x^*)&amp;=\sum_{i=1}^m\lambda_i \nabla g_i(\mathbfx^*)+\sum_{j=1}^l\mu_j \nabla h_j(\mathbf x^*) \Leftrightarrow\nabla_{\mathbf x}L(\mathbf x^*,\mathbf \lambda,\mathbf \mu)=0   \\KKT \quad conditions:\\\,\,\,\,\quad g_i(\mathbf x^*)&amp;\le0\quad i=1,...,m\\\mu_jh_j(\mathbf x^*)&amp;=0\quad j=1,...,l \\\quad \qquad \lambda_i&amp;\ge0\quad i=1,...,m\\\,\, \lambda_ig_i(\mathbf x^*)&amp;=0 \quad i=1,...,m\end{align}\tag{1.23}\]</span> <strong>Example —— 最大化离散分布的信息熵</strong>假设有一组随机变量 <span class="math inline">\(S=\{s_1,s_2,...s_n\}\)</span>, 对应的概率分布为<span class="math inline">\(\mathbf p=\{p_1,p_2,...,p_n\}\)</span>,求最大化信息熵的概率分布。该问题可表述为在概率归一化条件的约束下n个变量的优化问题：<span class="math display">\[\begin{align}max \quad S(p_1,...,p_n)&amp;=-\sum_{i=1}^np_ilnp_i\\s.t. \quad \sum_{i=1}^np_i-1&amp;=0\end{align}\tag{1.24}\]</span> 定义Lagrange函数： <span class="math display">\[L(p_1,...p_n,\lambda)=S(p_1,...,p_n)+\lambda(\sum_{i=1}^np_i-1)\tag{1.25}\]</span> 极值条件为以下n+1个方程： <span class="math display">\[\begin{align}\frac{\partial L}{\partialp_i}&amp;=-(lnp_i+1)+\lambda=0\quad i=1,...,n\\\frac{\partial L}{\partial \lambda}&amp;=\sum_{i=1}^np_i-1=0\end{align}\tag{1.26}\]</span> 则 <span class="math inline">\(p_1=\cdots=p_n=\frac{1}{n},\lambda=1-ln{\,n}\)</span>.可见无其他约束条件下，均匀分布使信息熵最大化。</p><h3 id="正则系综canonical-ensemble">正则系综(Canonical Ensemble)</h3><blockquote><p>There is, essentially, only one problem in statisticalthermodynamics, the distribution of a given amount of energy E overidentical systems. Or perhaps better, to determine the distribution ofan assembly of identical systems over the possible states in which thesystem can find itself given that the energy of the assembly is aconstant E.</p><p>——Schrodinger</p></blockquote><p><img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础3.png" alt="平衡态统计力学基础3" style="zoom:33%;"></p><p>​自然界和实验条件下，系统往往与环境有能量和物质交换，并非完全孤立。考虑实验上更容易制备和操控的宏观态<span class="math inline">\((N,V,T)\)</span>，其粒子数和体积固定，通过与环境的热平衡维持温度不变。系统达平衡时，包括内能所有热力学量不变。系综的平均能量不变，但每个瞬间系统的能量可任意取值。​考虑这样的系综：各个副本的体积和粒子数固定，相互之间可交换热量并达到热平衡，整个系综是孤立体系，总能不变(从而平均能量不变)。系综中的每个系统相当于浸没在无限大热浴中，这类似于推导系综概率分布的第一种方式。假设系统可能的微观态为<span class="math inline">\(\{\mu_i\}\)</span>, 系综的<span class="math inline">\(A\)</span>个体系在各微观态上的一种分配方式构成组态(分布)<span class="math inline">\(C=\{n_i\}\)</span>，<span class="math inline">\(\{n_i\}\)</span>是满足 <span class="math inline">\(\sum_{i} n_i=A\)</span>的所有可能整数集。宏观体系具有可分辨性，交换不同微观态上的系统产生新的组合，每种组态的组合数即为其统计权重<span class="math inline">\(W\{n_i\}=\frac{A!}{\prod_{i}n_i!}\)</span>，物理量的平均值为各组态对应值的加权平均：<span class="math display">\[&lt;f&gt;=\frac{\sum_{C=\{n_i\}}f\{n_i\}W\{n_i\}}{\sum_{C=\{n_i\}}W\{n_i\}}\tag{1.27}\]</span> 当 <span class="math inline">\(A\to\infty\)</span> ，<span class="math inline">\(W\{n_i\}\)</span> 取得尖锐的极大值<span class="math inline">\(W\{n_i^*\}\)</span>。最概然分布法的核心思想就是用占主导地位的<span class="math inline">\(\{n_i^*\}\)</span>项取代式(1.27)的求和来计算系综平均。同时Boltzmann熵也用最概然分布的组合数计算，显然最终的公式与信息熵如出一致。相较于传统的繁琐方式，信息熵提供了等价而简洁的推导。</p><p>假设系综的微观态集合为 <span class="math inline">\(M=\{\mu_i\}\)</span>, 微观态的能量为<span class="math inline">\(E=\{\cal E_i\}\)</span>，对应的概率分布为<span class="math inline">\(\mathbfp=\{p_i\}\)</span>，在归一化条件和平均能量等于内能的约束下求最优分布：<span class="math display">\[\begin{align}max \quad S_I(\{p_i\})&amp;=-\sum_{i}p_ilnp_i\\s.t. \quad \sum_{i}p_i-1&amp;=0\\\quad \sum_{i}p_i{\cal E_i}-U&amp;=0 \end{align}\tag{1.28}\]</span> Lagrange函数： <span class="math display">\[L(p_i,\lambda)=S_I(p_i)+\alpha(\sum_{i}p_i-1)\tag{1.29}-\beta(\sum_{i}p_i{\calE_i}-U)\]</span> 极值条件： <span class="math display">\[\begin{align}\frac{\partial L}{\partialp_i}&amp;=-(lnp_i+1)+\alpha-\beta {\cal E_i} =0\quad \\\frac{\partial L}{\partial \alpha}&amp;= \sum_{i}p_i-1=0\\\frac{\partial L}{\partial \beta}&amp;= -\sum_{i}p_i{\calE_i}+U=0\end{align}\tag{1.30}\]</span> 可得 <span class="math display">\[p_i=exp(\alpha-1)exp(-\beta {\cal E_i}) \tag{1.31}\]</span> 从归一化条件得： <span class="math display">\[p_i=\frac{exp(-\beta {\cal E_i})}{Z(\beta)} \tag{1.32}\]</span> 正则配分函数定义为 <span class="math inline">\(Z(\beta)=\sum_iexp(-\beta {\calE_i})\)</span>，式中对所有可能的微观态求和。对经典系统： <span class="math inline">\(Z(\beta)=\frac{1}{h^{3N}N!}\int e^{-\beta\hat{\cal H}(\mathbf p,\mathbf q)} \,d\Gamma\)</span>. 热力学熵 <span class="math display">\[S=k_BS_I=k_B\beta U+k_BlnZ(\beta)\tag{1.33}\]</span> 当N、V固定时，<span class="math inline">\(S\)</span> 只是<span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(U\)</span> 的函数，这两个变量相互关联 ：<span class="math inline">\(U=\sum_ip_i(\beta){\calE_i}\)</span>。根据温度的热力学定义： <span class="math display">\[\Bigl (\frac{\partial S}{\partial U}\Bigl )_{N,V}= \Bigl (\frac{\partialS}{\partial U}\Bigl )_{\beta,N,V}+\Bigl (\frac{\partial S}{\partial\beta}\Bigl )_{U,N,V}\Bigl (\frac{\partial \beta}{\partial U}\Bigl)_{N,V}=k_B\beta=\frac{1}{T}\tag{1.34}\]</span> 因而<span class="math inline">\(\beta =1/k_BT\)</span>，由此熵的定义桥接了统计力学和热力学。若已知正则配分函数，结合热力学基本关系可推导出所有的热力学量。其中Helmholz自由能与配分函数直接关联，是正则系综的特性函数：<span class="math display">\[F=-k_BT\,ln{Z(N,V,T)}\tag{1.35}\]</span></p><h3 id="等温等压系综isothermal-isobaric-ensemble">等温等压系综(Isothermal-isobaricEnsemble)</h3><p><img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础4.png" alt="平衡态统计力学基础4" style="zoom:33%;"><span class="math inline">\((N,P,T)\)</span>系综几乎是分子动力学模拟中最常用的系综，这源于自然界中等温等压环境的普遍性以及<span class="math inline">\((N,P,T)\)</span>系综与Gibbs自由能的直接关联。系统与环境交换热量和功达到平衡，保持温度T和压强P(广义力<span class="math inline">\(J\)</span>)稳定，能量E与体积V(广义位移x)在平衡值附近波动。相应的优化问题增加了约束条件：<span class="math inline">\(\sum_{i}p_i{\calV_i}-V=0\)</span>。求解可得概率分布： <span class="math display">\[p_i=\frac{exp(-\frac{ {\cal E_i}+P{\cal V_i}}{k_BT})}{Z(N,P,T)}\tag{1.36}\]</span> 配分函数 <span class="math display">\[\begin{align}Z(N,P,T)&amp;=\sum_i exp(-\frac{ {\cal E_i}+P{\calV_i}}{k_BT})\\\qquad \qquad \qquad \qquad \qquad &amp;=\int_0^\inftyexp(-\frac{P{}V}{k_BT})\,Z(N,V,T)\,dV \end{align} \tag{1.37}\]</span> 等温等压系综的特性函数是Gibbs自由能： <span class="math display">\[G=-k_BT\,ln\,Z(N,P,T)\tag{1.38}\]</span> ### 巨正则系综(Grand Canonical Ensemble)</p><p><img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础5.png" alt="平衡态统计力学基础5" style="zoom:33%;">巨正则系综的系统与环境交换热量和粒子，宏观态由 <span class="math inline">\((\mu,V,T)\)</span>参量确定。在3个约束条件下求取最概然分布： <span class="math display">\[\begin{align}\quad \sum_{i}p_i-1&amp;=0\\\sum_{i}p_i{\cal E_i}-U&amp;=0 \\\sum_{i}p_i{\calN_i}-N&amp;=0                           \end{align}\tag{1.39}\]</span> 从而 <span class="math display">\[p(\mu_i)=\frac{exp(-\frac{ {\cal E_i}-\mu{\cal N_i}}{k_BT})}{Q(\mu,V,T)}\tag{1.36}\]</span> 巨正则配分函数可用 N 粒子正则配分函数表达： <span class="math display">\[\begin{align}Q(\mu,V,T)&amp;=\sum_{i}exp(-\frac{ {\cal E_i}-\mu{\calN_i}}{k_BT})\\\quad \,\,\,\quad\qquad &amp;=\sum_{N=0}^\infty e^{\muN/k_BT}\,Z(N,V,T)\tag{1.37}\end{align}\]</span> 定义 <span class="math inline">\(f=e^{\mu /k_BT}\)</span>为逸度。系统具有N个粒子的无条件概率为： <span class="math display">\[p(N)=\frac{e^{\mu N/k_BT}\,Z(N,V,T)}{Q(\mu,V,T)}\tag{1.38}\]</span> 巨正则系统的特性函数为巨势(grand potential)： <span class="math display">\[\quad\Phi_G=-k_BT\,ln\,Q(\mu,V,T)=U-TS-\mu N=-PV\tag{1.39}\]</span> ## 涨落与系综等价性 正则系综能量的相对方均根涨落为 <span class="math display">\[\frac{\sqrt{\sigma_E^2}}{U}=\frac{\sqrt{&lt;({\calE}-U)^2&gt;}}{U}=k_B^{-1/2}T\frac{C_v^{1/2}}{U} \sim N^{-1/2} \tag{1.40}\]</span> 有限温度下当 <span class="math inline">\(N\to \infty\)</span>时，能量涨落趋于零。 而巨正则系综的粒子数涨落为（证明较复杂，利用<span class="math inline">\(\bigl (\frac{\partial \mu}{\partial\overline{N}}\bigl)_{V,T}=-\frac{V^2}{\overline{N}^2}\big(\frac{\partialp}{\partial V}\big)_{N,T}\)</span>的关系）： <span class="math display">\[\frac{\sqrt{\sigma_N^2}}{\overline{N}}=\frac{k_BT}{\overline{N}}\Bigl(\frac{\partial \overline{N}}{\partial \mu}\Bigl)_{V,T}=(k_BT\kappa_T/V)^{1/2}\sim N^{-1/2} \tag{1.41}\]</span> 其中等温压缩率 <span class="math inline">\(\kappa_T\)</span>是强度性质，对均相体系一般具有与N无关的有限值，因而上式成立。而对于临界点附近或相变区，<span class="math inline">\(\kappa_T\)</span> 无穷大，以致粒子数涨落显著。巨正则系综能量的方差为 <span class="math display">\[\sigma_E^2=−(\frac{∂U}{∂\beta}​)_{z,V}​=k_BT^2C_V​+k_BT\Bigl(\frac{∂U}{∂V}​\Bigl)_{T,V}​\Bigl(\frac{∂U}{∂μ}\Bigl)_{T,V}=\sigma_{E^2}(正则)​+\Bigl\{\Bigl(\frac{∂U}{∂N}​\Bigl)_{T,V​}\Bigl\}^2\sigma_N^2​​​\tag{1.42}\]</span>说明在巨正则系综中系统的能量的方均涨落等于在正则系综能量的方均涨落加上由于粒子数涨落所产生的贡献。一般情况下宏观相对能量涨落可以忽略，但在临界点和相变区，涨落的值受第二项影响而变得异常的大。以上讨论表明，除了临界点和相变区，热力学极限下正则系综和巨正则系综的能量涨落和巨正则系综的粒子数涨落都可以忽略不计，相当于微正则系综<span class="math inline">\((N,V,E)\)</span>。因而从正则系综和巨正则系综推导的热力学性质与微正则系综相同，热力学极限下各种系综等价。</p><h2 id="系综理论小结">系综理论小结</h2><ul><li><p>宏观系统的状态由系统在各个微观态上确定的概率分布描述</p></li><li><p>稳态是概率分布不随时间变化</p></li><li><p>局域平衡态是稳态，且微观态（相点）之间的没有净的概率流（满足精细平衡原理）的概率分布。局域平衡态使得特性函数取极值。如微正则局域平衡态使得<span class="math inline">\(S[\rho]\)</span> 取极大值。</p></li><li><p>全局平衡态是最概然分布，使得特性函数取得全局最大/最小值的分布，如正则系综是使得<span class="math inline">\(A[\rho]\)</span>取全局极小值的分布<span class="math inline">\(\rho_0\)</span>。</p></li><li><p>通常我们讨论的平衡态都是局域平衡态，尤其是对复杂体系。平衡态是相对于一定时间定义的。例如重力场中的静置的玻璃，在几年之内其宏观性质都不会变化，但几十年甚至几万年后重力作用会使得它发生形变，在大的时间尺度上，原来的玻璃并没有处于全局平衡态。</p><p>但在通常的实验测量的时间尺度上，讨论全局平衡态没有太多意义。宏观体系的相空间几乎不能在通常的时间尺度、通常的条件下遍历，系统本身应该只局限于部分相空间。</p></li><li><p>只需要各态遍历、等概率公设、熵的统计定义三个假设，以及热力学量的定义和基本关系式，就可以推出不同条件下的平衡概率分布和用配分函数表达的热力学量。</p></li></ul><h1 id="量子系综理论的密度矩阵形式">量子系综理论的密度矩阵形式</h1><p><img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础6.png" alt="平衡态统计力学基础6" style="zoom:50%;">量子力学中，系统可能的微观态具有离散的取值（本征态)，真实的状态为这些本征态的线性叠加。将配分函数中对可能微观态的求和写成对本征态求和，即可描述纯态的量子体系。但纯态的描述只适合孤立体系，对于与环境耦合的量子体系，微观态和宏观态的定义不同。</p><p>​量子力学具有与不确定性关联的内在概率性，这导致量子统计中的两次求平均。考虑一个随时间演化的量子系统，在一段时间内观测系统，其宏观态表现为不同时刻的态矢<span class="math inline">\(\{s_1,s_2,...,s_n\}\)</span>形成的混合态，物理量观测值就是这些微观态相应性质的时间平均，随时间段的移动观测值可能变化，也可能达到稳定——平衡态。然而对某一时刻的系统观测物理量<span class="math inline">\(f\)</span>，得到的观测值并不是确定值，而是一套本征值<span class="math inline">\(\{f_1,f_2,...\}\)</span>中的一个，每种本征值出现的可能性与态矢关于本征矢的展开系数<span class="math inline">\(\bra{\Phi_i}\ket{\Psi }\)</span>有关。如果制备许多相同的<span class="math inline">\(\ket{\Psi(t_0)}\)</span>，对应于 t<sub>0</sub>时刻的系统，对这些样本(平行重复实验)观测的平均值就是期望值<span class="math inline">\(\bra {\Psi}\hatf\ket\Psi\)</span>。这两种平均可分别可比作一台粒子加速器不同时刻的结果与多台加速器上同一时刻结果的统计。这样宏观物理量就是首先求物理量关于每个时刻对应态矢的期望值，再对不同时刻期望值求<em>移动平均值</em>的结果。然而我们并不想求解宏观系统的含时薛定谔方程，参考经典统计的做法，我们将宏观态与态矢的集合<span class="math inline">\(\{\ket{\Psi_\alpha}\}\)</span>，以及相应的概率分布<span class="math inline">\(\{p_\alpha\}\)</span>对应，这样这种时间移动平均就转换为对系综的统计平均。现在让我们推导量子系综理论的表现形式。量子系统的微观态可由无限维Hilbert空间中的单位矢$$完全确定，即将态矢用正交归一的完备基集展开：<span class="math display">\[\ket \Psi =\sum_n \bra{n}\ket{\Psi}\ket{n} \tag{1.43}\]</span> 归一化条件： <span class="math display">\[\bra{\Psi}\ket{\Psi}=\sum_n\bra{\Psi}\ket{n}\bra{n}\ket{\Psi}=1\tag{1.44}\]</span> 物理量 <span class="math inline">\(O\)</span> 的期望值为：<span class="math display">\[\left&lt;\hat O\right&gt; =\bra {\Psi}\hatO\ket{\Psi}=\sum_{n,m}\bra{\Psi}\ket{m}\bra{m}\hatO\ket{n}\bra{n}\ket{\Psi} \tag{1.45}\]</span> <span class="math inline">\(O_{mn}=\bra{m}{\hatO}\ket{n}\)</span> 为算符 <span class="math inline">\(\hat O\)</span>在正交基<span class="math inline">\(\{|n\ket\}\)</span>下表示矩阵的矩阵元。矩阵 <span class="math inline">\(\bfO\)</span> 是Hermitian矩阵。 考虑到系综的统计平均： <span class="math display">\[\overline{\left&lt;\hat O\right&gt;}=\sum_\alpha p_\alpha\bra{\Psi_\alpha}\hat O\ket{\Psi_\alpha}=\sum_{m,n}\sum_\alpha p_\alpha\bra{\Psi_\alpha}\ket{m}\bra{m}\hat O\ket{n}\bra{n}\ket{\Psi_\alpha}=\sum_{m,n}\bra{n}{\hat \rho}\ket{m} O_{mn}=tr(\bf \rho O)\tag{1.46}\]</span> 这里我们定义了密度算符： <span class="math display">\[\hat \rho(t)=\sum_\alpha p_\alpha\ket{\Psi_\alpha}\bra{\Psi_\alpha}\tag{1.47}\]</span> 当且仅当系综只由一个态矢描述，<span class="math inline">\(\hat\rho(t)=\ket{\Psi}\bra{\Psi }\)</span> 即 <span class="math inline">\(\bf \rho^2=\rho\)</span> 时，称之为纯态(purestate)系综。 密度矩阵(densitymatrix)具有以下性质：(1)归一化(Normalization) <span class="math inline">\(tr(\rho)=\sum_\alpha p_\alpha=1\)</span>(2)厄米性(Hermiticity) (3)正定性。 由式(1.46)，只需知道密度矩阵 <span class="math inline">\(\rho\)</span> 和 算符 <span class="math inline">\(\hat O\)</span>的矩阵表示，就可以计算物理量O的系综平均。这表明系统的宏观态可由密度矩阵完全确定。类似经典统计中将系统的宏观态映射到相空间中的密度分布，量子统计将宏观态映射到Hilbert空间中的密度矩阵。现在让我们考虑密度矩阵随时间的演化。我们知道态矢的演化遵循含时薛定谔方程：<span class="math display">\[i\hbar \frac{\partial}{\partial t}\ket{\Psi(t)}=\hat {\calH}\ket{\Psi(t)} \tag{1.48}\]</span> 自然地，我们采用能量本征态展开态矢，则有： <span class="math display">\[i\hbar \frac{\partial}{\partial t}\bra{n}\ket{\Psi}=\cal E_n\bra{n}\ket{\Psi} \tag{1.49}\]</span> 则 <span class="math display">\[i\hbar \frac{\partial}{\partial t}\bra{n}{\hat\rho(t)}\ket{m}=\sum_\alpha p_\alpha[(\cal E_n-\calE_m)\bra{n}\ket{\Psi_\alpha}\bra{\Psi_\alpha}\ket{m}]=\bra{n}{\hat{\cal H}\rho-\rho\hat {\cal H} }\ket{m}\tag{1.50}\]</span>这是一个张量不变的等式，即与基集的选择无关。这就是量子Liouville方程：<span class="math display">\[i\hbar \frac{\partial}{\partial t}\hat \rho=[\hat {\cal H},\hat\rho]\tag{1.51}\]</span> 类似于经典统计，如果<span class="math inline">\(\hat \rho=\hat\rho(\hat{\cal H})\)</span>，则 <span class="math inline">\(\partial{\hat \rho} /\partial t=0\)</span>(可证明量子力学算符的对易子等于经典的Poisson括号乘以 <span class="math inline">\(i\hbar\)</span> ，因而 <span class="math inline">\(\hat{\cal H}\)</span> 与 <span class="math inline">\(\hat \rho\)</span>对易)。如同基于相空间的经典统计，基于密度矩阵的形式，量子统计也建立了严格的框架。在密度矩阵的形式中重新表述系综理论：- 微正则系综密度算子为</p><p><span class="math display">\[\hat \rho(E)=\frac{\delta(\hat {\cal H}-E)}{\Omega(E)}\tag{1.52}\]</span> 其矩阵元 <span class="math display">\[\bra{n}{\hat \rho}\ket{m}=\begin{cases}1/\Omega \quad if\,{\calE_n}=E,\,\,and\,\,\, m=n\\ 0 \quad if \,{\cal E_n}\neq E,\,\, or\,\,\,m\neq n\end{cases}\tag{1.53}\]</span> 其中<span class="math inline">\(\Omega(E)\)</span>就是能量为E的本征态数目。需提及由于<span class="math inline">\([\hat {\cal H},\hat\rho]=0\)</span>，在能量本征态基集下密度矩阵对角化，因而 <span class="math inline">\(m\neq n\)</span> 的矩阵元为0。值得一提的是纯态系综 <span class="math inline">\(\Omega=1\)</span>，对应于热力学第三定律所言熵为0的情况，而混合态系综的熵大于0。等概率假设导致了式(1.53)中对角元相同，为了保证在其他表象中该条件仍成立，还需无规相位假设。</p><p>==为什么需要密度矩阵？是因为波函数表达的是一系列相互纠缠的态，而与环境接触达到热平衡的体相，各个态之间显然不是完全关联，其相位随机取向，密度矩阵表达的是就是这样微观态随机出现的宏观态。（这部分还有待细看）==</p><ul><li>正则系综</li></ul><p><span class="math display">\[\hat \rho(\beta)=\frac{exp(-\beta\hat {\cal H})}{Z(\beta)}\tag{1.53}\]</span> 算子根据麦克劳林展开定义：<span class="math inline">\(e^{-\beta \hat{\cal H}}= 1-\beta\hat {\calH}+\frac{1}{2}\beta^2 \hat {\cal H}^2+\cdots\)</span>。显然其作用于能量本征态上得到 <span class="math inline">\(e^{-\beta\cal E}\)</span> 。 根据密度矩阵的归一化条件，配分函数： <span class="math display">\[Z(\beta)=tr(e^{-\beta \hat{\cal H}})=\sum_\mu e^{-\beta \calE(\mu)}\tag{1.54}\]</span>得到与之前假设离散的微观态相同的结果。因而我们可以通过在任意正交基下计算<span class="math inline">\(e^{-\beta \hat{\calH}}\)</span>的矩阵元并求矩阵的迹来得到配分函数，也可以对角化Hamiltonian矩阵，得到能量本征值(及简并度)从而计算配分函数。- 巨正则系综</p><p><span class="math display">\[\rho(\beta,\mu)=\frac{e^{-\beta \hat {\cal H}+\beta \mu\hat N}}{Q}\tag{1.55}\]</span> <span class="math display">\[Q(\beta,\mu)=tr(e^{-\beta \hat {\cal H}+\beta \mu\hatN})=\sum_{N=0}^\infty e^{\beta \mu N}Z(N,\beta)\tag{1.56}\]</span> 经典统计中，密度函数 <span class="math inline">\(\rho(\bfp,q)\)</span>表示相空间某一点的概率密度。而在量子统计中，密度矩阵的对角元 <span class="math inline">\(\rho_{nn}\)</span> 表示基函数<span class="math inline">\(\ket{n}\)</span>权重的统计平均 <span class="math inline">\(\sum_np_\alpha \bra{n} \ket{\Psi_\alpha}\bra{\Psi_\alpha}\ket{n}\)</span>. 如果我们将<span class="math inline">\(\ket{\Psi_\alpha}\)</span>设为本征态（这是相当自然的事情），并在能量表象下写出密度矩阵，则其对角元<span class="math inline">\(\rho_n = p_n\)</span> 就是本征态<span class="math inline">\(\ket{n}\)</span>的出现概率（平衡态下密度矩阵与Hamiltonian具有共同本征态，其本征值就是概率）。量子与经典统计的相似性显而异见。</p><p>##各种系综的比较以及热力学量计算</p><p>这里比较了各种系综的概率分布函数、归一化系数的表达式。 <img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础6.jpg" alt="平衡态统计力学基础6"></p><h1 id="理想气体从量子统计到经典统计">理想气体：从量子统计到经典统计</h1><p>由于粒子不可分辨性对波函数对称性施加的约束，确定合法的能量本征态并非易事。即使对理想气体，我们能很容易对角化单粒子Hamiltonian，从单粒子能量本征值推断多粒子体系的允许能级，我们仍需费一些功夫筛选符合波函数交换对称性的多粒子态，确定态密度，从而才能计算配分函数。首先我们讨论对波函数的一般要求。由于粒子的全同性，交换两个粒子的空间-自旋坐标并不产生新的状态，概率密度保持不变：<span class="math display">\[|\Psi(\vec q_1,\vec q_2)|^2=|\Psi(\vec q_2,\vec q_1)|^2\tag{1.57}\]</span> 这就要求对交换两个粒子坐标的操作，波函数不变或反号：<span class="math inline">\(\ket{\Psi(\vec q_1,\vec q_2)} = \ket{\Psi(\vecq_2,\vec q_1)}\)</span> or <span class="math inline">\(\ket{\Psi(\vecq_1,\vec q_2)} = -\ket{\Psi(\vec q_2,\vecq_1)}\)</span>。更一般地，对交换粒子坐标产生新排列的置换操作<span class="math inline">\(\hatP\)</span>，有对称和反对称的波函数，分别对应自然界中的玻色子(Bosons)和费米子(Fermions):<span class="math display">\[\begin{align}Bosons:\quad \hatP\ket{\Psi(1,...,N)}&amp;=+P\ket{\Psi(1,...,N)}\\Fermions:\quad \hatP\ket{\Psi(1,...,N)}&amp;=(-1)^PP\ket{\Psi(1,...,N)}\tag{1.58}\end{align}\]</span> 其中P是产生排列所需的置换次数。显然置换不使Hamiltonian改变。现在考虑量子理想气体。假设我们已经对角化单粒子Hamiltonian <span class="math inline">\(\hat h\)</span>，得到单粒子本征态<span class="math inline">\(\{\ket{\psi}\}\)</span>。现在我们构造N粒子态。显然乘积态(productstate) <span class="math inline">\(\ket{\psi_1,...,\psi_N}_\otimes=\ket{\psi_1(1)}\cdots\ket{\psi_N(N)}\)</span>是Hamiltonian<span class="math inline">\(\hat {\cal H}=\sum_{\alpha=1}^N \hath_\alpha\)</span>的本征态，但它不满足对任意置换操作保持不变或反号的要求。为此需用所有可能的N! 个乘积态线性组合来构造N粒子态。对费米子，反对称(anti-symmetric)的N粒子态为Slater行列式(虽然是Dirac发明)：<span class="math display">\[\ket{\Psi}=\frac{1}{\sqrt N!}\sum_P(-1)^P\hatP\ket{\psi_1(1),...,\psi_N(1)}_\otimes=\frac{1}{\sqrt N!}\begin{vmatrix}  \psi_1(1)  &amp;\psi_2(1)  &amp;\cdots &amp;\psi_N(1)\\  \psi_1(2)  &amp;\psi_2(2)  &amp;\cdots &amp;\psi_N(2)\\\vdots &amp; \vdots &amp;  &amp;  \vdots  \\  \psi_1(N)&amp;  \psi_2(N) &amp;\cdots &amp;\psi_N(N)  \end{vmatrix} \tag{1.59}\]</span> 其要求组成乘积态的单粒子态不能有重复，否则行列式为0。对玻色子则没有任何对单粒子态出现次数的限制。假设乘积态中每个占据态的出现次数为<span class="math inline">\(\{n_{i}\}\)</span>, 满足 <span class="math inline">\(\sum_{i=1}^{occ}n_i=N\)</span>.如果有重复出现的单粒子态，则式(1.60)的求和中必有重复的乘积态项，化简后不重复的项数为<span class="math inline">\(\frac{N!}{\prod_i^{occ}n_i!}\)</span>。又由于单粒子态的正交归一，序列不同的乘积态之间矩阵元为0，只有序列相同的之间矩阵元为1，可得归一化系数<span class="math inline">\(N_+=N!\prod_i^{occ}n_i\)</span>。 <span class="math display">\[\ket{\Psi}=\frac{1}{\sqrt N_+}\sum_P\hatP\ket{\psi_1(1),...,\psi_N(1)}_\otimes\tag{1.60}\]</span>费米子和玻色子波函数对称性对单粒子态填充的限制不同，造就了它们不同的统计。对费米子，一个单粒子态上的占据数为0或1（Fermi-Dirac统计）；对玻色子，占据数可取任意自然数（Bose–Einstein统计）。现在我们计算配分函数。由于粒子的全同性，N粒子态完全由一组占据数<span class="math inline">\(\{n_i\}\)</span>（组态）确定，则： <span class="math display">\[Z_N(\beta)=tr(e^{-\beta \hat {\cal H}})=\sum_{s.t. \sum_in_i=N}exp(-\beta \sum_i\cal E_in_i)\tag{1.61}\]</span> 其中<span class="math inline">\(\calE_i\)</span>是单粒子态的能量。除了占据数之和等于N的约束1，占据数还受到粒子本身交换对称性的约束2。我们难以计算式(1.61)的约束求和。Kardar展示了在坐标表象下求正则配分函数的一系列复杂操作，然而在能量表象下我们可以绕过<span class="math inline">\(Z_N\)</span>。通过对所有可能的N值求和，将两次求和变为一次解除约束1的求和（这样占据数就可以相互独立变化，这是一个令人印象深刻的技巧）：<span class="math display">\[Q(\mu,\beta)=\sum_{N=0}^\infty e^{\beta \mu N}\,Z_N(\beta)=\sum_{N=0}^\infty\sum_{\{n_i\}&#39;}\prod_i e^{-\beta(\calE_i-\mu)n_i}=\sum_{\{n_i\}}\prod_i e^{-\beta(\cal E_i-\mu)n_i}=\prod_i\sum_{n_i}e^{-\beta(\cal E_i-\mu)n_i} \tag{1.62}\]</span>最后面的连乘是对所有的单粒子态进行，求和是对所有满足对称性要求的n<sub>i</sub> 进行： <span class="math display">\[\begin{align}&amp;For\,\, fermions,\,n_i=0\,\,or\,\,1: \\&amp;Q_-=\prod_i[1+exp(\beta \mu-\beta{\cal E_i})]\\&amp;For\,\, bosons,\,n_i=0,1,2,...:\\&amp;Q_+=\prod_i[1-exp(\beta\mu-\beta {\calE_i})]^{-1}\end{align}\tag{1.63}\]</span> N粒子态<span class="math inline">\(\ket{\{n_i\}}\)</span>的出现概率为： <span class="math display">\[p(\ket{\{n_i\} })=\frac{1}{Q}\prod_iexp(\beta\mu-\beta{\calE}_i)\tag{1.64}\]</span>不打算在本文中列出详细的推导，只说结论。无论是从何种表示出发，我们都得出量子气体表现得如同相互作用气体，其virial状态方程为（其中g为自旋多重度2s+1，对fermions<span class="math inline">\(\eta=-1\)</span>，对boson <span class="math inline">\(\eta=+1\)</span>s；热波长<span class="math inline">\(\lambda=\frac{\hbar}{\sqrt{2\pi k_BT}}\)</span>）：<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础7.png" alt="平衡态统计力学基础7" style="zoom:33%;">非简并情况的正则配分函数：<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础8.png" alt="平衡态统计力学基础8" style="zoom:33%;">我们看到量子效应的大小由简并参数 <span class="math inline">\(\frac{n_\eta \lambda^3}{g}\)</span>衡量，在高温、低密度极限（热波长远小于粒子间距，波函数几乎不重叠），单粒子态充分可及，交换作用效应很小，状态方程和配分函数只保留第一项，与经典的结果相同。然而在低温高密度，状态方程的二阶、三价等高阶项变得重要，使体系偏离理想气体。其情形就像粒子之间存在相互作用势：费米子相互排斥、玻色子相互吸引。这实际上是因为波函数对称性的约束使得粒子的空间分布不再相互独立，粒子间存在空间（可能还加上自旋）关联作用。配分函数的第二项即对应两个粒子的交换作用，导致状态方程中的二阶virial系数，高阶项则对应三体、四体等多体作用，可以用团簇展开技术求解这些项。<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础9.png" alt="平衡态统计力学基础9" style="zoom:33%;">化学向的书在处理这部分内容常常采用最概然分布近似，只考虑粒子在能级上最可能的分布方式对微观状态数的贡献（微正则系综）。在热力学极限下，最概然分布形成尖锐的极大，其结果理与严格处理一致。<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础10.png" alt="平衡态统计力学基础10" style="zoom:33%;">至此，我们以较严谨的方式搭建了统计力学基础，并完成了量子到经典的过渡。我们看到，高温、低密度极限下，经典统计近似成立，对于质量较大的粒子，其相同温度下其热波长较小，量子效应相对不显著。这构成了我们今后遇到的大多数情况下，将原子核/原子当做经典粒子处理的前提。对于无相互作用体系（固体中的相互独立的声子和理想气体），我们可以用Maxwell-Boltzmann统计处理，即当做可分辨粒子计数，但用除以N!因子校正。对于相互作用的复杂体系，我们需要借助各种算法来进行构型采样（仍视原子为可分辨的粒子），获取能谱来计算配分函数（进行校正)。补充：巨正则系综中无自旋气体的平均能量和粒子数<img src="/2024/07/05/equi-statistical-basis/平衡态统计力学基础11.png" alt="平衡态统计力学基础11" style="zoom:33%;"></p><h1 id="参考资料">参考资料</h1><ol type="1"><li>Kardar, M. (2007). <em>Statistical Physics of Particles</em>.Cambridge: Cambridge University Press.</li><li>Stephen Blundell &amp; Katherine M. Blundell. (2010). <em>Conceptsin Thermal Physics</em>. Oxford: Oxford University Press.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Science</category>
      
      <category>Computational Chemistry</category>
      
      <category>Molecular Dynamics</category>
      
      <category>Statistical Mechanics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Statistical Mechanics</tag>
      
      <tag>Classical Mechanics</tag>
      
      <tag>Quantum Mechanics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Molecular Dynamics in NVT ensemble (Working On)</title>
    <link href="/2024/07/05/nvt-md/"/>
    <url>/2024/07/05/nvt-md/</url>
    
    <content type="html"><![CDATA[<h1 id="热力学回顾">热力学回顾</h1><p>对熵<span class="math inline">\(S(E,V)\)</span>进行勒让德变换得到一个等价的热力学函数——亥姆霍兹自由能：<span class="math display">\[A=E-TS\]</span> 热力学基本方程</p><p><span class="math display">\[dA=-SdT-pdV+\mu dN\]</span> 特性函数 <span class="math display">\[A(N,V,T)=-k_BTln Z(N,V,T)\]</span></p><p>正则配分函数 <span class="math inline">\(Z(N,V,T)\)</span>​相当于用玻尔兹曼因子对态密度进行加权平均，可视为温度T下系统可及的量子态数目：<span class="math display">\[Z(N,V,T)=\frac{1}{N{!}h^{3N}}\int e^{-\beta \hat H({\bf p,q})}d^{3N}{\bfp}d^{3N}{\bf q}=\int \Omega(N,V,T)e^{-\beta E}dE\]</span> 正则概率分布： <span class="math display">\[P({\bf p,q})=\frac{e^{-\beta\hat H({\bf p,q})}}{Z(N,V,T)}\]</span></p><p>同样可以在正则系综中证明位力定理： <span class="math display">\[&lt;x_i\frac{\partial \hat H}{\partial x_j}&gt;=k_BT\delta_{ij}\]</span></p><p><span class="math inline">\(x_i\)</span>是任意一个自由度的位移或动量。位力定理给出能量均分原理，每个自由度分配到<span class="math inline">\(1/2k_BT\)</span>的能量，每个粒子的平均动能为： <span class="math display">\[&lt;E_{ki}&gt;=&lt;\frac{\bf p_i^2}{2m_i}&gt;=\frac{3}{2}k_BT\]</span> 分子动力学中常用的温度定义为： <span class="math display">\[T=\frac{2&lt;E_k&gt;}{3Nk_B}\]</span> 该定义与热力学定义是一致的。可以定义瞬时温度。</p><p><img src="/2024/07/05/nvt-md/clip_image002.jpg" style="zoom:50%;"></p><h1 id="恒温器">恒温器</h1><p>​分子动力学中使用恒温器/热浴(Thermostats)来维持温度，产生正确的NVT或NPT系综分布。</p><p>不同热浴有不同适用场景，结合文献说明各种热浴适用范围</p><p>理想体系上的测试离实际太远，还是需要结合文献案例和算例说明到底应该选什么热浴</p><p>不能产生正确系综分布到底对实际体系的计算影响多大，比如说自由能，这是很重要的事情</p><h2 id="速度缩放velocity-scaling">速度缩放(Velocity Scaling)</h2><h3 id="berendsen-thermostat">Berendsen thermostat</h3><p>预手衡常用不保证正确的分布</p><h3 id="velocity-rescaling-temperature-coupling">Velocity-rescalingtemperature coupling</h3><h3 id="随机热浴stochastic-thermostat">随机热浴(StochasticThermostat)</h3><h3 id="andersen热浴">Andersen热浴</h3><p>随机热海，如Audersen.thermstat，能产生正河分布,但动力学性质计算上不合适(如粘度).</p><h3 id="langevin热浴">Langevin热浴</h3><p><span class="math display">\[\langle {\stackrel{\circ}{r}}_i\!\!(t) {\stackrel{\circ}{r}}_j\!\!(t+s)\rangle = 2 m_i \gamma_i k_B T \delta(s) \delta_{ij}\]</span></p><h2 id="扩展系综法extended-ensemble-approach">扩展系综法(Extended-EnsembleApproach)</h2><p>扩展系综法的精髓是在真实的系统上附加虚拟的自由度（环境），真实系统与环境通过一定的势函数耦合为孤立体系。选择势函数使得平衡态下真实的体系的分布满足正确的系综分布。</p><p>这类右该是通过引入对应与热洛的动力学变量,使得物理体系采样到正刚</p><h3 id="nosé-hoover热浴">Nosé-Hoover热浴</h3><blockquote><p>https://sahu-lab.github.io/blog/2022/11/22/nose-hoover-theory.html(Github blog)</p></blockquote><h3 id="nosé-hamiltonian">Nosé Hamiltonian</h3><p><img src="/2024/07/05/nvt-md/clip_image004.jpg" alt="img" style="zoom: 50%;"><img src="/2024/07/05/nvt-md/clip_image006.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image008.jpg" alt="img" style="zoom:50%;"></p><h3 id="nosé-hoover-chain-thermostat">Nosé-Hoover Chain Thermostat</h3><p><img src="/2024/07/05/nvt-md/clip_image010.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image012.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image014.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image016.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image018.jpg" alt="img" style="zoom:50%;"><img src="/2024/07/05/nvt-md/clip_image020.jpg" alt="img" style="zoom:50%;"></p><ul><li>Conserved Quantity</li></ul><p><span class="math display">\[\hat H_{NH}=\sum_{i=1}^N \frac{ {\bf p}_i^2}{2m_i}+U({\bf r}_1,...,{\bfr}_N)+\frac{p_{\eta}^2}{2Q}+dNkT_0\eta\]</span></p><ul><li>Equations <span class="math display">\[\begin{align}\dot r_i &amp;=\frac{p_i}{m_i} \\\dot \eta &amp;= \frac{p_{\eta}}{Q} \\\dot p_i &amp;=F_i-\frac{p_{\eta}}{Q}\\\dot p_{\eta} &amp;= dNk(T-T_0)\end{align}\]</span></li></ul><h3 id="nosé-hoover-chain">Nosé-Hoover Chain</h3><ul><li>Conserved Quantity</li></ul><p><span class="math display">\[\hat H_{NHC}=\sum_{i=1}^N \frac{ {\bf p}_i^2}{2m_i}+U({\bf r}_1,...,{\bfr}_N)+\sum_{j=1}^M\frac{p_{\eta_j}^2}{2Q_j}+dNkT_0\eta_1+kT_0\sum_{j=2}^M \eta_j\]</span></p><ul><li><p>Equations <span class="math display">\[\begin{align}\dot r_i &amp;=\frac{p_i}{m_i} \\\dot \eta_j &amp;= \frac{p_{\eta_j}}{Q_j} \\\dot p_i &amp;=F_i-\frac{p_{\eta_1}}{Q_1}\\\dot p_{\eta_1} &amp;=dNk(T-T_0)-\frac{p_{\eta_{j+1}}}{Q_{j+1}}p_{\eta_j}\\\dot p_{\eta_j} &amp;=[\frac{p_{\eta_{j-1}}^2}{Q_{j-1}}-kT_0]-\frac{p_{\eta_{j+1}}}{Q_{j+1}}p_{\eta_j}\\\dot p_{\eta_M} &amp;= [\frac{p_{\eta_{M-1}}^2}{Q_{M-1}}-kT_0]\end{align}\]</span></p><ul><li>Explict Reversible Intergrators 如果运动方程(EOM)有以下形式:</li></ul></li></ul><p><span class="math display">\[\dot {\bf x}=Zeta({\bf x})\]</span></p><p>则Liourille算符: <span class="math display">\[i\hat L=Zeta({\bf x})\cdot \nabla _{\bf x}\]</span> 将Liourille算符分解为三项: <span class="math display">\[i\hat L=i\hat L_1+i\hat L_2+i\hat L_{NHC}\]</span> 分别为: <span class="math display">\[\begin{align}    i\hat L_1 &amp;=\sum_{i=1}^N{\bf v}_i\cdot \nabla_{ {\bf r}_i}\\    i\hat L_2 &amp;=\sum_{i=1}^N\frac{ {\bf F}_i}{m_i} \cdot \nabla_{{\bf v}_i}\\    i\hat L_{NHC} &amp;=-\sum_{i=1}^N v_{\eta_1} {\bf v}_i \cdot\nabla_{ {\bf v}_i}+\sum_{j=1}^M v_{\eta_j}\cdot\frac{\partial}{\partial\eta_j}+\sum_{j=1}^{M-1}(G_j-v_{\eta_{j+1}}v_{\eta_j})\frac{\partial}{\partial v_{\eta_j}}+G_M\frac{\partial}{\partialv_{\eta_M}}\end{align}\]</span> 系统/第 j-1 个热浴作用于第 j 个热浴的力产生的加速度Gj 为:<span class="math display">\[\begin{align}G_1 &amp;=\frac{1}{Q_1}(\sum_{i=1}^N\frac{ {\bfp}_i^2}{m_i}-dNkT_0)=\frac{1}{Q_1dNk}(T-T_0)\\G_j&amp;=\frac{1}{Q_j}(\frac{p^2_{\eta_{j-1}}}{Q_{j-1}}-kT_0)=\frac{1}{Q_j}(Q_{j-1}v_{\eta_j}^2-kT_0)\end{align}\]</span> 其中瞬时温度T定义为： <span class="math display">\[T=\frac{1}{dNk}\sum_{i=1}^N\frac{ {\bf p}_i^2}{m_i}\]</span> <span class="math inline">\(i\hat L_1\)</span>、<span class="math inline">\(i\hat L_2\)</span>、<span class="math inline">\(i\hatL_{NHC}\)</span>三项相互之间不可对易，而<span class="math inline">\(i\hatL_{NHC}\)</span>的前两项以及这两项求和符号中的每一项相互对易。首先使用一次Trotter分解：</p><p><span class="math display">\[exp(i\hat L \Delta t)\approx exp(i\hat L_{NHC}\frac{\Delta t}{2})\timesexp(i\hat L_2\frac{\Delta t}{2})\times exp(i\hat L_1\Delta t)\timesexp(i\hat L_2\frac{\Delta t}{2})\times exp(i\hat L_{NHC}\frac{\Deltat}{2})\]</span> 中间部分是标准的VelocityVerlet算法。由于热浴力变化迅速，热浴部分传播子的积分需采用远小于物理系统部分的时间步，即RESPA算法，但这需要的时间步非常小。或对热浴部分采用更高阶的因子化，从而降低对时间步的要求，如Suzuki-Yoshida方案：定义 <span class="math inline">\(exp(\lambda \hat A\hat B)\)</span> 的primitive factorization： <span class="math display">\[S(\lambda)= exp({\frac{\lambda\hat B}{2})\times exp(\lambda\hatA})\times exp(\frac{\lambda\hat B }{2})\]</span></p><p>则 <span class="math inline">\(exp(\lambda \hat A\hat B)\)</span>可写成 primitive factorization加权连乘的形式： <span class="math display">\[exp(\lambda \hat A\hat B)\approx \prod^{n_{sy}}_{\alpha=1}S(w_\alpha\lambda)\]</span> 其中 <span class="math inline">\(w_\alpha\)</span>为权重。六阶因子化的权重为： <span class="math display">\[w_1 = w_7 = 0.784513610477560 \\w_2 = w_6 = 0.235573213359357 \\w_3 = w_5 = -1.17767998417887 \\w_4 = 1 - w_1 - w_2 - w_3 - w_5 - w_6 - w_7\]</span> 从而热浴部分的传播子可写成： <span class="math display">\[exp(i\hat L_{NHC}\frac{\Delta t}{2})\approx\prod^{n_{sy}}_{\alpha=1}S(w_\alpha\frac{\Delta t}{2n})\]</span> 其中 <span class="math inline">\(\delta_\alpha=w_\alpha\frac{\Delta t}{n}\)</span>是primitivefactorization的时间步。利用Trotter分解，按热浴index从大到小的顺序依次展开相应的“热浴速度”项<span class="math inline">\(G_M\frac{\partial}{\partialv_{\eta_M}}\)</span> 和 <span class="math inline">\((G_j-v_{\eta_{j+1}}v_{\eta_j})\frac{\partial}{\partial v_{\eta_j}}\)</span>。中间的<span class="math inline">\(exp(\frac{\delta_\alpha}{2}i\hatL_{NHC1})\)</span>和<span class="math inline">\(exp(\frac{\delta_\alpha}{2}i\hatL_{NHC2})\)</span>项可以直接写成连乘： <span class="math display">\[S(\delta_\alpha/2)=exp(\frac{\delta_\alpha}{4}G_M\frac{\partial}{\partial v_{\eta_M}})\times \prod_{j=M-1}^1exp\{\frac{\delta_\alpha}{4}(G_j-v_{\eta_{j+1}}v_{\eta_j})\frac{\partial}{\partial v_{\eta_j}}\} \times \\\prod_{i=1}^{N}exp(-\frac{\delta_\alpha}{2}v_{\eta_1}{\bf v}_i\cdot\frac{\partial}{\partial {\bf v}_i}) \times \prod_{j=1}^Mexp(\frac{\delta_\alpha}{2}v_{\eta_j}\cdot \frac{\partial}{\partial\eta_j})\times \\ \prod_{j&#39;=1}^{M-1}exp\{\frac{\delta_\alpha}{4}(G_j-v_{\eta_{j+1}}v_{\eta_j})\frac{\partial}{\partial v_{\eta_j}}\} \timesexp(\frac{\delta_\alpha}{4}G_M\frac{\partial }{\partial v_{\eta_M}})\]</span> <span class="math inline">\(exp\{\frac{\delta_\alpha}{4}(G_j-v_{\eta_{j+1}}v_{\eta_j})\frac{\partial}{\partial v_{\eta_j}}\}\)</span>项可以被精确求解，对应于变换： <span class="math display">\[v_{\eta_j} \tov_{\eta_j}exp(-v_{\eta_{j+1}}\frac{\delta_\alpha}{4})+\frac{\delta_\alpha}{4}G_j\,exp(-v_{\eta_{j+1}}\frac{\delta_\alpha}{8})\frac{sinh(\frac{\delta_\alpha}{8}v_{\eta_{j+1}})}{\frac{\delta_\alpha}{8}v_{\eta_{j+1}}}\]</span> 其中涉及双曲函数： <span class="math display">\[sinh(x)=\frac{e^x-e^{-x}}{2}\]</span> 如果采用Trotter分解，上式变为： <span class="math display">\[v_{\eta_j} \tov_{\eta_j}exp(-v_{\eta_{j+1}}\frac{\delta_\alpha}{4})+\frac{\delta_\alpha}{4}G_j\,exp(-v_{\eta_{j+1}}\frac{\delta_\alpha}{8})\]</span>变化较缓的第一项（物理体系的动量更新）和第二项（热浴位移变量的更新）放在最中间，用最长的时间步。</p><p>计算物理体系和热浴变量动量的摩擦项时需处理以下形式的算符： <span class="math display">\[exp(cx\frac{\partial }{\partial x})f(x)=f (xe^c)\]</span> 作用于相空间矢量则有： <span class="math display">\[exp(cx\frac{\partial }{\partial x})x=xe^c\]</span> 重要公式：<img src="/2024/07/05/nvt-md/正则系综与恒温动力学.png" alt="正则系综与恒温动力学" style="zoom: 33%;"></p><p><img src="/2024/07/05/nvt-md/正则系综与恒温动力学2.png" alt="正则系综与恒温动力学2" style="zoom:33%;"></p><p><img src="/2024/07/05/nvt-md/正则系综与恒温动力学3.png" alt="正则系综与恒温动力学3" style="zoom:33%;"></p><ul><li>Code Structure of a constant-temperature MD program<ul><li>Setting up the parameters:<ul><li><p>the time step: <span class="math inline">\(\Delta t\)</span>​ and"n" for the thermostat part (chosen according to the natural frequencyof the fast motion in the physical system.)</p></li><li><p>the number of steps: n<br></p></li><li><p>Mass: <span class="math inline">\(\{m_i\}\)</span><br></p></li><li><p>Topology and force field parameters</p></li><li><p>the target temperature: <span class="math inline">\(T_0\)</span></p></li><li><p>the number of thermostats: <span class="math inline">\(M\)</span></p></li><li><p>“effective mass”:</p></li></ul></li></ul></li></ul><p><span class="math display">\[\begin{align}Q_1 &amp;= dNkT τ^2\\Qj &amp;= kT τ^2, j = 2, ..., M\end{align}\]</span></p><p>where <span class="math inline">\(τ\)</span> is a characteristic timescale in the system. A reasonable choice is <span class="math inline">\(τ ≥ 20Δt\)</span>.</p><ul><li>Initialization Coordinatons of the physical system: <span class="math inline">\(\{x_i,y_i,z_i\}\)</span> Velocities: <span class="math inline">\(\{v_{x,i},v_{y,i},v_{z,i}\}\)</span> Initialvalues of the thermostat viriables: <span class="math inline">\(\{\eta_i,v_{\eta_i}\}\)</span></li></ul><blockquote><p>Circling:</p></blockquote><ul><li>Integrating the Nosé–Hoover chain equations (single step) Input:<span class="math inline">\(\{x_i,y_i,z_i\}\)</span>, <span class="math inline">\(\{v_{x,i},v_{y,i},v_{z,i}\}\)</span> , <span class="math inline">\(\{\eta_i,v_{\eta_i}\}\)</span> , Forces and <span class="math inline">\(T\)</span> at time <span class="math inline">\(t\)</span> Output: <span class="math inline">\(\{x_i,y_i,z_i\}\)</span>, <span class="math inline">\(\{v_{x,i},v_{y,i},v_{z,i}\}\)</span> , <span class="math inline">\(\{\eta_i,v_{\eta_i}\}\)</span>, Forces and <span class="math inline">\(T\)</span> at time <span class="math inline">\(t+\Delta t\)</span> Applying Periodic BoundaryCondition (Correcting the particle coordinations)</li><li>Evalutating some properties: such as total energy, kinetic energy,potential energy, pressure...</li><li>Store or output some variables</li></ul><blockquote><ul><li>Post-processing of the MD trajectory</li></ul></blockquote><h3 id="d-harmonic-oscillator">1D harmonic oscillator</h3><ul><li>setting up the simulation parameters</li><li>initialization</li><li>integrating the Nosé-Hoover chain equations until the max time stepis reached</li><li>analysis</li></ul><p>Code: Parameter setting and initialization</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setParm</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">   set up the simulation parameters with a interactive way</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> k<br>    k=<span class="hljs-number">0.0083144621</span>  <span class="hljs-comment"># MD单位下的玻尔兹曼常数</span><br>    <span class="hljs-comment">#注意：函数内可以使用全局变量但不能修改，除非函数开头加global关键字声明</span><br>    <span class="hljs-keyword">global</span> dt<br>    <span class="hljs-keyword">global</span> nthermo<br>    <span class="hljs-keyword">global</span> dtmo<br>    <span class="hljs-keyword">global</span> nstep<br>    <span class="hljs-keyword">global</span> T0<br>    <span class="hljs-keyword">global</span> M<br>    <span class="hljs-keyword">global</span> Q<br>    <span class="hljs-keyword">global</span> r<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> KE<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> m<br>    <span class="hljs-keyword">global</span> omega<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Set up the simulation paramaters&quot;</span>)<br>    dt=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the time step (ps): &quot;</span>))<br>    nthermo=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the proportion that dt/dt(NHC): &quot;</span>))<br>    dtmo=np.zeros(<span class="hljs-number">7</span>)<br>    <span class="hljs-keyword">for</span> ntt <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>): <br>        dtmo[<span class="hljs-number">0</span>]= <span class="hljs-number">0.784513610477560</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">6</span>]= dtmo[<span class="hljs-number">0</span>]<br>        dtmo[<span class="hljs-number">1</span>]= <span class="hljs-number">0.235573213359357</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">5</span>]= dtmo[<span class="hljs-number">1</span>]<br>        dtmo[<span class="hljs-number">2</span>]= -<span class="hljs-number">1.17767998417887</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">4</span>]= dtmo[<span class="hljs-number">2</span>]<br>        dtmo[<span class="hljs-number">3</span>]= (<span class="hljs-number">1</span>-(<span class="hljs-number">0.784513610477560</span>-<span class="hljs-number">0.235573213359357</span>+<span class="hljs-number">1.17767998417887</span>)*<span class="hljs-number">2</span>)*dt/nthermo<br>    nstep=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the number of the simulation steps: &quot;</span>))<br>    T0=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the target temperature (K): &quot;</span>))<br>    M=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the number of thermostats: &quot;</span>))<br>    tao=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;to set up the &#x27;effective mass&#x27; of Nose-Hoover Chains, input the character time scale &#x27;tao&#x27;( unit: ps, e.g. tao&gt;=20*dt): &quot;</span>))<br>    Q=np.zeros(M)<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> np.arange(M):<br>        Q[m]=k*T0*tao*tao<br>    r=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the initial position(nm): &quot;</span>))<br>    m=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the particle mass (a.u.): &quot;</span>))<br>    velocity=sqrt(k*T0)<br>    T=T0<br>    KE=<span class="hljs-number">0.5</span>*k*T<br>    omega=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the nature frequency of oscillor: &quot;</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setParm2</span>(<span class="hljs-params">dti,nthermoi,nstepi,T0i,Mi,taoi,x0i,mi,omegai</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    :: setParm2(dti,nthermoi,nstepi,T0i,Mi,taoi,x0i,mi,omegai)</span><br><span class="hljs-string">    set up the simulation parameters directly</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    dti:  the time step (ps)</span><br><span class="hljs-string">    nthermoi:  the proportion that dt/dt(NHC)</span><br><span class="hljs-string">    nstepi:   the number of the simulation steps</span><br><span class="hljs-string">    T0i:   the target temperature (K)</span><br><span class="hljs-string">    Mi:  the number of thermostats</span><br><span class="hljs-string">    taoi:   the character time scale &#x27;tao&#x27;(ps)</span><br><span class="hljs-string">    x0i:  the initial position(nm)</span><br><span class="hljs-string">    mi:  the particle mass (a.u.)</span><br><span class="hljs-string">    omegai:   the nature frequency of oscillor</span><br><span class="hljs-string">    </span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> k<br>    k=<span class="hljs-number">0.0083144621</span>  <span class="hljs-comment"># MD单位下的玻尔兹曼常数</span><br>    <span class="hljs-comment">#注意：函数内可以使用全局变量但不能修改，除非函数开头加global关键字声明</span><br>    <span class="hljs-keyword">global</span> dt<br>    <span class="hljs-keyword">global</span> nthermo<br>    <span class="hljs-keyword">global</span> dtmo<br>    <span class="hljs-keyword">global</span> nstep<br>    <span class="hljs-keyword">global</span> T0<br>    <span class="hljs-keyword">global</span> M<br>    <span class="hljs-keyword">global</span> Q<br>    <span class="hljs-keyword">global</span> r<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> KE<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> m<br>    <span class="hljs-keyword">global</span> omega<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Set up the simulation paramaters&quot;</span>)<br>    dt=dti<br>    nthermo=nthermoi<br>    dtmo=np.zeros(<span class="hljs-number">7</span>)<br>    <span class="hljs-keyword">for</span> ntt <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>): <br>        dtmo[<span class="hljs-number">0</span>]= <span class="hljs-number">0.784513610477560</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">6</span>]= dtmo[<span class="hljs-number">0</span>]<br>        dtmo[<span class="hljs-number">1</span>]= <span class="hljs-number">0.235573213359357</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">5</span>]= dtmo[<span class="hljs-number">1</span>]<br>        dtmo[<span class="hljs-number">2</span>]= -<span class="hljs-number">1.17767998417887</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">4</span>]= dtmo[<span class="hljs-number">2</span>]<br>        dtmo[<span class="hljs-number">3</span>]= (<span class="hljs-number">1</span>-(<span class="hljs-number">0.784513610477560</span>-<span class="hljs-number">0.235573213359357</span>+<span class="hljs-number">1.17767998417887</span>)*<span class="hljs-number">2</span>)*dt/nthermo<br>    nstep=nstepi<br>    T0=T0i<br>    M=Mi<br>    tao=taoi<br>    Q=np.zeros(M)<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> np.arange(M):<br>        Q[m]=k*T0*tao*tao<br>    r=x0i<br>    m=mi<br>    velocity=sqrt(k*T0)<br>    T=T0<br>    KE=<span class="hljs-number">0.5</span>*k*T<br>    omega=omegai<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_G</span>():<br>    <span class="hljs-keyword">global</span> G<br>    G=np.zeros(M)<br>    G[<span class="hljs-number">0</span>]=k*(T-T0)<br>    <span class="hljs-keyword">for</span> ng <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,M):<br>        G[ng]=(Q[ng-<span class="hljs-number">1</span>]*vEta[ng-<span class="hljs-number">1</span>]*vEta[ng-<span class="hljs-number">1</span>]-k*T0)/Q[ng]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_nhc</span>(<span class="hljs-params">label</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    initialize the thermostat variablea and their velocities</span><br><span class="hljs-string">    parameter: &quot;random&quot;/&quot;zero&quot;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> eta<br>    <span class="hljs-keyword">global</span> vEta<br>    <span class="hljs-keyword">if</span> label==<span class="hljs-string">&quot;random&quot;</span>:      <br>        np.random.seed(<span class="hljs-number">19588801</span>)<br>        eta = np.random.rand(M)<br>        vEta = np.random.rand(M)<br>    <span class="hljs-keyword">elif</span> label==<span class="hljs-string">&quot;zero&quot;</span>:<br>        eta=np.zeros(M)<br>        vEta=np.zeros(M)<br></code></pre></td></tr></table></figure><p>Equation solvers and force calculator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">NHCstep</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    solve the Nosé-Hoover Chain equations using &quot;explict rversible intergrators&quot; in a single step</span><br><span class="hljs-string">    changed global variable：particle positions: r; particle velosity: velocity; physical forces: Force; </span><br><span class="hljs-string">              M* eta; M* vEta; thermostat forces M* G ; potential energy UE.</span><br><span class="hljs-string">              kinetic energy KE, instantaneous temperature T </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> nweight <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> ns <span class="hljs-keyword">in</span> np.arange(nthermo):<br>            Soperator(dtmo[nweight])<br>    vverletStep()<br>    <span class="hljs-keyword">for</span> nweight <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> ns <span class="hljs-keyword">in</span> np.arange(nthermo):<br>            Soperator(dtmo[nweight])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Soperator</span>(<span class="hljs-params">tm</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    tm : the time step of each weight in the exp(iLnhc)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> vEta<br>    <span class="hljs-keyword">global</span> G<br>    <span class="hljs-keyword">global</span> eta<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> KE<br><br>    vEta[M-<span class="hljs-number">1</span>]+=G[M-<span class="hljs-number">1</span>]*tm/<span class="hljs-number">4</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> np.flipud(np.arange(M-<span class="hljs-number">1</span>)):        <span class="hljs-comment">#逆向序列 [M-2,M-3,...,0]</span><br>        vt_tmp=tm/<span class="hljs-number">8</span>*vEta[jj+<span class="hljs-number">1</span>]<br>        vEta[jj]*=exp(-vt_tmp)<br>        vEta[jj]+=tm/<span class="hljs-number">4</span>*G[jj]                  <span class="hljs-comment">#exect:  *sinh(vt_tmp)/(vt_tmp)</span><br>        vEta[jj]*=exp(-vt_tmp)<br>        G[jj+<span class="hljs-number">1</span>]=(Q[jj]*vEta[jj]*vEta[jj]-k*T0)/Q[jj+<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(M):<br>        eta[j]+=tm/<span class="hljs-number">2</span>*vEta[j]<br>    velocity*=exp(-tm/<span class="hljs-number">2</span>*vEta[<span class="hljs-number">0</span>])<br>    KE= m*velocity*velocity<br>    T=KE/k<br>    G[<span class="hljs-number">0</span>]=k*(T-T0)<br>    KE*=<span class="hljs-number">0.5</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(M-<span class="hljs-number">1</span>):<br>        vt_tmp=tm/<span class="hljs-number">8</span>*vEta[j+<span class="hljs-number">1</span>]<br>        vEta[j]*=exp(-vt_tmp)<br>        vEta[j]+=tm/<span class="hljs-number">4</span>*G[j]                    <span class="hljs-comment">#exect:    *sinh(vt_tmp)/(vt_tmp)</span><br>        vEta[j]*=exp(-vt_tmp)<br>        G[j+<span class="hljs-number">1</span>]=(Q[j]*vEta[j]*vEta[j]-k*T0)/Q[j+<span class="hljs-number">1</span>]<br>    vEta[M-<span class="hljs-number">1</span>]+=G[M-<span class="hljs-number">1</span>]*tm/<span class="hljs-number">4</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vverletStep</span>():<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> r<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> KE<br>    velocity+=dt/<span class="hljs-number">2</span>*Force/m<br>    r+=dt*velocity        <br>    oscforce()<br>    velocity+=dt/<span class="hljs-number">2</span>*Force/m<br>    KE=m*velocity*velocity<br>    T=KE/k<br>    G[<span class="hljs-number">0</span>]=k*(T-T0)<br>    KE*=<span class="hljs-number">0.5</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">oscforce</span>():<br>    <span class="hljs-keyword">global</span> Force<br>    <span class="hljs-keyword">global</span> UE<br>    <br>    Force=-m*omega*omega*r<br>    UE=<span class="hljs-number">0.5</span>*m*omega*omega*r*r<br></code></pre></td></tr></table></figure><p>main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sinh, exp, sqrt, pi<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> log, sin, cos<br>%matplotlib inline <br><span class="hljs-keyword">global</span> time<br><span class="hljs-keyword">global</span> ncount<br>nstep=<span class="hljs-number">10000</span><br>Ts=np.zeros(nstep+<span class="hljs-number">1</span>)<br>KEs=np.zeros(nstep+<span class="hljs-number">1</span>)<br>UEs=np.zeros(nstep+<span class="hljs-number">1</span>)<br>vstore=np.zeros(nstep+<span class="hljs-number">1</span>)<br>xstore=np.zeros(nstep+<span class="hljs-number">1</span>)<br>times=np.zeros(nstep+<span class="hljs-number">1</span>)<br>setParm2(<span class="hljs-number">0.1</span>,<span class="hljs-number">50</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">100</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">#setParm2(dt,nc,nstep,T0,M,tao,x0,m,omega)</span><br>oscforce()<br>initial_nhc(<span class="hljs-string">&quot;zero&quot;</span>)<br>initial_G()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simulation start!&quot;</span>)<br>ncount=<span class="hljs-number">0</span><br>time=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> ncount &lt;= nstep:<br>    Ts[ncount]=T<br>    KEs[ncount]=KE<br>    UEs[ncount]=UE<br>    xstore[ncount]=r<br>    vstore[ncount]=velocity<br>    times[ncount]=time<br>    <span class="hljs-comment">#print(time,T,KE,UE)</span><br>    NHCstep()<br>    time=ncount*dt<br>    ncount=ncount+<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simulation finish!&quot;</span>)<br>plt.figure(figsize=[<span class="hljs-number">16</span>,<span class="hljs-number">16</span>],dpi=<span class="hljs-number">150</span>)<br>plt.subplot(<span class="hljs-number">221</span>)<br>plt.xlabel(<span class="hljs-string">&quot;time&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Temperature&quot;</span>)<br>avT=np.zeros(nstep+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> np.arange(nstep+<span class="hljs-number">1</span>):<br>    avT[n]=<span class="hljs-built_in">sum</span>(Ts[<span class="hljs-number">0</span>:n+<span class="hljs-number">1</span>])/(n+<span class="hljs-number">1</span>)<br><br>plt.scatter(times,Ts,label=<span class="hljs-string">&quot;Instantious Temperature&quot;</span>,marker=<span class="hljs-string">&#x27;p&#x27;</span>,alpha=<span class="hljs-number">0.5</span>,s=<span class="hljs-number">0.1</span>)<br>plt.plot(times,avT,label=<span class="hljs-string">&quot;Average Temperature&quot;</span>,color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.scatter(times[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">20</span>],<span class="hljs-number">100</span>*np.ones(nstep+<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">20</span>],label=<span class="hljs-string">&quot;Target Temperature&quot;</span>,s=<span class="hljs-number">5</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.legend()<br>plt.subplot(<span class="hljs-number">222</span>)<br>plt.xlabel(<span class="hljs-string">&quot;velocity&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;PDF&quot;</span>)<br>plt.hist(vstore,bins=<span class="hljs-number">100</span>, density=<span class="hljs-literal">True</span>,label=<span class="hljs-string">&#x27;Simulation&#x27;</span>)<br>vx=np.linspace(-<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100</span>)<br>ve=sqrt(m/(<span class="hljs-number">2</span>*pi*k*T0))*np.exp(-<span class="hljs-number">0.5</span>*m*vx**<span class="hljs-number">2</span>/k/T0)<br>plt.plot(vx,ve,label=<span class="hljs-string">&#x27;MB distribution&#x27;</span>)<br>plt.legend()<br>plt.subplot(<span class="hljs-number">223</span>)<br>plt.xlabel(<span class="hljs-string">&quot;x&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;PDF&quot;</span>)<br>plt.hist(xstore,bins=<span class="hljs-number">100</span>,density=<span class="hljs-literal">True</span>,color=<span class="hljs-string">&quot;g&quot;</span>,alpha=<span class="hljs-number">0.8</span>,label=<span class="hljs-string">&#x27;Simulation&#x27;</span>)<br>xx=np.linspace(-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>)<br>px=sqrt(m*omega**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*pi*k*T0))*np.exp(-<span class="hljs-number">0.5</span>*m*omega*omega*xx**<span class="hljs-number">2</span>/k/T0)<br>plt.plot(xx,px,color=<span class="hljs-string">&#x27;r&#x27;</span>,label=<span class="hljs-string">&#x27;Exact distribution&#x27;</span>)<br>plt.legend()<br>plt.subplot(<span class="hljs-number">224</span>)<br>plt.xlabel(<span class="hljs-string">&quot;p&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;x&quot;</span>)<br>plt.scatter(m*vstore[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">1</span>],xstore[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">1</span>],color=<span class="hljs-string">&#x27;r&#x27;</span>,marker=<span class="hljs-string">&#x27;.&#x27;</span>,s=<span class="hljs-number">1</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>Result:</p><ol type="1"><li>Nosé-Hoover and Nosé-Hoover Chains the time step (ps): 0.1 theproportion that dt/dt(NHC): 100 the number of the simulation steps:10000 the target temperature (K): 100 the character time scale τ (ps): 1the initial position(nm): 0 the initial velocity(nm/ps): srqt(kT0/m) theparticle mass (a.u.): 1 the nature frequency of oscillor: 1 the initialvalue of all the thermostat variables: 0 Nosé-Hoover<img src="/2024/07/05/nvt-md/正则系综与恒温动力学4.png" alt="正则系综与恒温动力学4" style="zoom:25%;">Nosé-Hoover Chains: M=3<img src="/2024/07/05/nvt-md/正则系综与恒温动力学5.png" alt="正则系综与恒温动力学5" style="zoom: 25%;"></li><li>The influence of <span class="math inline">\(dt/dt_{NHC}\)</span>:让我们考虑多时间步算法中物理时间步与热浴时间步之比对误差的影响。总时间步4000，用Nosé-Hoover热浴，即使dt/dt(NHC)达到25,3800处以后也会产生肉眼可见的误差。<img src="/2024/07/05/nvt-md/正则系综与恒温动力学6.png" alt="正则系综与恒温动力学6" style="zoom: 25%;">即使采用更高的比例，在较长的模拟时间下也会产生客观的误差。测试中也发现比例提高，计算耗时显著增加。当然这仅对谐振子等低维体系成立，大体系的计算耗时主要在力和势能的计算，这一比例的增加影响相对较小。<img src="/2024/07/05/nvt-md/正则系综与恒温动力学7.png" alt="正则系综与恒温动力学7" style="zoom: 25%;"></li><li>τ即有效质量对采样效果的影响 the time step (ps): 0.1 the proportionthat dt/dt(NHC): 50 the number of the simulation steps: 2000 the targettemperature (K): 100 the number of thermostats: 2 the initialposition(nm): 0 the particle mass (a.u.): 1 the nature frequency ofoscillor: 1 （初始速度按目标温度设置，初始热浴变量设为0）</li></ol><ul><li>thermal inertia (Q)越大，温度的波动频率越高，波动幅度越小</li><li>Q值影响采样的遍历性，过大或过小都不合适，根据运动的自然时间尺度设定的Q值更有利于采样到正则分布。也就是说热浴和物理体系运动的时间尺度应相互匹配才能实现有效耦合。<img src="/2024/07/05/nvt-md/正则系综与恒温动力学8.png" alt="正则系综与恒温动力学8"></li></ul><p><img src="/2024/07/05/nvt-md/正则系综与恒温动力学9.png" alt="正则系综与恒温动力学9"></p><h3 id="nosé-poincaré-method">Nosé-Poincaré Method</h3><h1 id="reference">Reference</h1><blockquote><ol type="1"><li>Mark E. Tuckerman. (2010). <em>Statistical Mechanics: Theory andMolecular Simulation</em>. Oxford: Oxford University Press.</li><li>Molecular Dynamics at Constant Temperature:https://qijingzheng.github.io/posts/NVT-MD/</li><li></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Science</category>
      
      <category>Computational Chemistry</category>
      
      <category>Molecular Dynamics</category>
      
      <category>Statistical Mechanics</category>
      
      <category>Working On</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Molecular Dynamics</tag>
      
      <tag>Statistical Mechanics</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Python Demo for MD simulation of Lennard-Jones Fluid in NVT Ensemble</title>
    <link href="/2024/02/11/LJ-fluid-simulation/"/>
    <url>/2024/02/11/LJ-fluid-simulation/</url>
    
    <content type="html"><![CDATA[<p>一个简单的demo，用Python实现在NVT系综中Lennard-Jones流体的分子动力学模拟。原理见MolecularDynamics in NVT ensemble一文。</p><h1 id="code-参数设置和变量初始化">Code: 参数设置和变量初始化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sinh, exp, sqrt, pi<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> log, sin, cos<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setParm</span>(<span class="hljs-params">dti,nthermoi,nstepi,Ni,T0i,Mi,taoi</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    :: setParm(dti,nthermoi,nstepi,T0i,Mi,taoi,x0i,mi,omegai)</span><br><span class="hljs-string">    set up the simulation parameters directly</span><br><span class="hljs-string"></span><br><span class="hljs-string">    dti:  the time step (ps)</span><br><span class="hljs-string">    nthermoi:  the proportion that dt/dt(NHC)</span><br><span class="hljs-string">    nstepi:   the number of the simulation steps</span><br><span class="hljs-string">    Ni： the number of particles</span><br><span class="hljs-string">    T0i:   the target temperature (K)</span><br><span class="hljs-string">    Mi:  the number of thermostats</span><br><span class="hljs-string">    taoi:   the character time scale &#x27;tao&#x27;(ps)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> k<br>    k=<span class="hljs-number">0.0083144621</span>  <span class="hljs-comment"># MD单位下的玻尔兹曼常数</span><br>    <span class="hljs-comment">#注意：函数内可以使用全局变量但不能修改，除非函数开头加global关键字声明</span><br>    <span class="hljs-keyword">global</span> dt<br>    <span class="hljs-keyword">global</span> nthermo<br>    <span class="hljs-keyword">global</span> dtmo<br>    <span class="hljs-keyword">global</span> nstep<br>    <span class="hljs-keyword">global</span> T0<br>    <span class="hljs-keyword">global</span> M<br>    <span class="hljs-keyword">global</span> Q<br>    <span class="hljs-keyword">global</span> N<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Set up the simulation paramaters&quot;</span>)<br>    dt=dti<br>    nthermo=nthermoi<br>    dtmo=np.zeros(<span class="hljs-number">7</span>)<br>    <span class="hljs-keyword">for</span> ntt <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>): <br>        dtmo[<span class="hljs-number">0</span>]= <span class="hljs-number">0.784513610477560</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">6</span>]= dtmo[<span class="hljs-number">0</span>]<br>        dtmo[<span class="hljs-number">1</span>]= <span class="hljs-number">0.235573213359357</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">5</span>]= dtmo[<span class="hljs-number">1</span>]<br>        dtmo[<span class="hljs-number">2</span>]= -<span class="hljs-number">1.17767998417887</span>*dt/nthermo<br>        dtmo[<span class="hljs-number">4</span>]= dtmo[<span class="hljs-number">2</span>]<br>        dtmo[<span class="hljs-number">3</span>]= (<span class="hljs-number">1</span>-(<span class="hljs-number">0.784513610477560</span>-<span class="hljs-number">0.235573213359357</span>+<span class="hljs-number">1.17767998417887</span>)*<span class="hljs-number">2</span>)*dt/nthermo<br>    nstep=nstepi<br>    N=Ni<br>    T0=T0i<br>    M=Mi<br>    tao=taoi<br>    Q=np.zeros(M)<br>    Q[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>*N*k*T0*tao*tao<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,M):<br>        Q[m]=k*T0*tao*tao<br>  <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setBC</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    setting up the boundary condition</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> pbc<br>    bcType=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the type of periodic boundary condition (e.g. &#x27;cubic&#x27;,&#x27;rectangle&#x27;,&#x27;noPBC&#x27;): &quot;</span>)<br>    <span class="hljs-keyword">if</span> bcType!=<span class="hljs-string">&quot;noPBC&quot;</span>:<br>        <span class="hljs-keyword">global</span> lxbox<br>        <span class="hljs-keyword">global</span> lybox<br>        <span class="hljs-keyword">global</span> lzbox<br>        <span class="hljs-keyword">if</span> bcType==<span class="hljs-string">&quot;cubic&quot;</span>:<br>            lxbox=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the length of the cubic box (nm): &quot;</span>))<br>            lybox=lxbox<br>            lzbox=lxbox<br>        <span class="hljs-keyword">else</span>:<br>            lxbox=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the x length of the box (nm): &quot;</span>))<br>            lybox=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the y length of the box (nm): &quot;</span>))<br>            lzbox=<span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;the z length of the box (nm): &quot;</span>))<br>        pbc=[bcType,lxbox,lybox,lzbox]<br>    <span class="hljs-keyword">else</span>:<br>        pbc=[]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_position</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    initialization of the particle positions: a N*3 array</span><br><span class="hljs-string">    only for monatomic system with single componment, N=a^3</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> r<br>    r=np.zeros([N,<span class="hljs-number">3</span>])<br>    a=<span class="hljs-built_in">pow</span>(N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,N+<span class="hljs-number">1</span>):<br>        r[i-<span class="hljs-number">1</span>]=np.array([(i%(a*a))%a,(i%(a*a))//a,i//(a*a)])*lxbox/a<br>        r[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=r[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-lxbox*<span class="hljs-built_in">round</span>(r[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]/lxbox)<br>        r[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=r[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-lybox*<span class="hljs-built_in">round</span>(r[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]/lybox)<br>        r[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=r[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]-lzbox*<span class="hljs-built_in">round</span>(r[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]/lzbox)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_velocity</span>(<span class="hljs-params">Ti</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    initialization of the particle velocity according to the MB distribution (it&#x27;s unnecessary)</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> KE<br>    <span class="hljs-keyword">global</span> T<br>    velocity = np.zeros([N,<span class="hljs-number">3</span>])<br>    T=Ti<br>    sigma=sqrt(k*T/m[<span class="hljs-number">0</span>])<br>    np.random.seed(<span class="hljs-number">19015601</span>)<br>    ran1 = np.random.rand(N)<br>    ran2 = np.random.rand(N)<br>    ran3 = np.random.rand(N)<br>    velocity[:,<span class="hljs-number">0</span>]= sigma*np.sqrt(-<span class="hljs-number">2</span>*log(<span class="hljs-number">1</span>-ran2))*cos(<span class="hljs-number">2</span>*pi*ran1)<br>    velocity[:,<span class="hljs-number">1</span>]= velocity[:,<span class="hljs-number">0</span>]/cos(<span class="hljs-number">2</span>*pi*ran1)*sin(<span class="hljs-number">2</span>*pi*ran1)<br>    velocity[:,<span class="hljs-number">2</span>]=sigma*np.sqrt(-<span class="hljs-number">2</span>*log(<span class="hljs-number">1</span>-ran2))*cos(<span class="hljs-number">2</span>*pi*ran3)<br><br>    sumv=<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">sum</span>(velocity))<br>    velocity=velocity-sumv/(N*<span class="hljs-number">3</span>)<br>    sumv2=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>        sumv2=sumv2+<span class="hljs-built_in">sum</span>(velocity[i]*velocity[i])*m[i]<br>    fs=sqrt(<span class="hljs-number">3</span>*N*k*T/sumv2)<br>    velocity*=fs<br><br>    KE=<span class="hljs-number">0.5</span>*<span class="hljs-number">3</span>*N*k*T<br><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_G</span>():<br>    <span class="hljs-keyword">global</span> G<br>    G=np.zeros(M)<br>    G[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>*N*k*(T-T0)<br>    <span class="hljs-keyword">for</span> ng <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">1</span>,M):<br>        G[ng]=(Q[ng-<span class="hljs-number">1</span>]*vEta[ng-<span class="hljs-number">1</span>]*vEta[ng-<span class="hljs-number">1</span>]-k*T0)/Q[ng]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_nhc</span>(<span class="hljs-params">label</span>):<br>    <span class="hljs-keyword">global</span> eta<br>    <span class="hljs-keyword">global</span> vEta<br>    <span class="hljs-keyword">if</span> label==<span class="hljs-string">&quot;random&quot;</span>:      <br>        np.random.seed(<span class="hljs-number">19588801</span>)<br>        eta = np.random.rand(M)<br>        vEta = np.random.rand(M)<br>    <span class="hljs-keyword">elif</span> label==<span class="hljs-string">&quot;zero&quot;</span>:<br>        eta=np.zeros(M)<br>        vEta=np.zeros(M)<br></code></pre></td></tr></table></figure><h1 id="code-单步积分器">Code: 单步积分器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">NHCstep</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    solve the Nosé-Hoover Chain equations using &quot;explict rversible intergrators in a single step</span><br><span class="hljs-string">    changed global variable：particle positions N*3 : r; particle velosity N*3: velocity; physical forces N*3: Force; </span><br><span class="hljs-string">              M* eta; M* vEta; thermostat forces M* G ; potential energy UE.</span><br><span class="hljs-string">              kinetic energy KE, instantaneous temperature T (but not be calculated in this function)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> nweight <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> ns <span class="hljs-keyword">in</span> np.arange(nthermo):<br>            Soperator(dtmo[nweight])<br>    vverletStep()<br>    <span class="hljs-keyword">for</span> nweight <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> ns <span class="hljs-keyword">in</span> np.arange(nthermo):<br>            Soperator(dtmo[nweight])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Soperator</span>(<span class="hljs-params">tm</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    tm : the time step of each weight in the exp(iLnhc)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> vEta<br>    <span class="hljs-keyword">global</span> G<br>    <span class="hljs-keyword">global</span> eta<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> KE<br><br>    vEta[M-<span class="hljs-number">1</span>]+=G[M-<span class="hljs-number">1</span>]*tm/<span class="hljs-number">4</span><br>    <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> np.flipud(np.arange(M-<span class="hljs-number">1</span>)):        <span class="hljs-comment">#逆向序列 [M-2,M-3,...,0]</span><br>        vt_tmp=tm/<span class="hljs-number">8</span>*vEta[jj+<span class="hljs-number">1</span>]<br>        vEta[jj]*=exp(-vt_tmp)<br>        vEta[jj]+=tm/<span class="hljs-number">4</span>*G[jj]                  <span class="hljs-comment">#exect:  *sinh(vt_tmp)/(vt_tmp)</span><br>        vEta[jj]*=exp(-vt_tmp)<br>        G[jj+<span class="hljs-number">1</span>]=(Q[jj]*vEta[jj]*vEta[jj]-k*T0)/Q[jj+<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(M):<br>        eta[j]+=tm/<span class="hljs-number">2</span>*vEta[j]<br>    KE=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>        velocity[i]*=exp(-tm/<span class="hljs-number">2</span>*vEta[<span class="hljs-number">0</span>])<br>        KE+= m[i]*<span class="hljs-built_in">sum</span>(velocity[i]*velocity[i])<br>    T=KE/(<span class="hljs-number">3</span>*N*k)<br>    G[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>*N*k*(T-T0)<br>    KE*=<span class="hljs-number">0.5</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(M-<span class="hljs-number">1</span>):<br>        vt_tmp=tm/<span class="hljs-number">8</span>*vEta[j+<span class="hljs-number">1</span>]<br>        vEta[j]*=exp(-vt_tmp)<br>        vEta[j]+=tm/<span class="hljs-number">4</span>*G[j]                    <span class="hljs-comment">#exect:    *sinh(vt_tmp)/(vt_tmp)</span><br>        vEta[j]*=exp(-vt_tmp)<br>        G[j+<span class="hljs-number">1</span>]=(Q[j]*vEta[j]*vEta[j]-k*T0)/Q[j+<span class="hljs-number">1</span>]<br>    vEta[M-<span class="hljs-number">1</span>]+=G[M-<span class="hljs-number">1</span>]*tm/<span class="hljs-number">4</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vverletStep</span>():<br>    <span class="hljs-keyword">global</span> velocity<br>    <span class="hljs-keyword">global</span> r<br>    <span class="hljs-keyword">global</span> T<br>    <span class="hljs-keyword">global</span> KE<br>    KE=<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">if</span> pbc!=[]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>            velocity[i]+=dt/<span class="hljs-number">2</span>*Force[i]/m[i]<br>            r[i]+=dt*velocity[i]<br>            r[i][<span class="hljs-number">0</span>]=r[i][<span class="hljs-number">0</span>]-lxbox*<span class="hljs-built_in">round</span>(r[i][<span class="hljs-number">0</span>]/lxbox)<br>            r[i][<span class="hljs-number">1</span>]=r[i][<span class="hljs-number">1</span>]-lybox*<span class="hljs-built_in">round</span>(r[i][<span class="hljs-number">1</span>]/lybox)<br>            r[i][<span class="hljs-number">2</span>]=r[i][<span class="hljs-number">2</span>]-lzbox*<span class="hljs-built_in">round</span>(r[i][<span class="hljs-number">2</span>]/lzbox)<br>        LJforce()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>            velocity[i]+=dt/<span class="hljs-number">2</span>*Force[i]/m[i]<br>            KE+=m[i]*<span class="hljs-built_in">sum</span>(velocity[i]*velocity[i])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>            velocity[i]+=dt/<span class="hljs-number">2</span>*Force[i]/m[i]<br>            r[i]+=dt*velocity[i]        <br>        LJforce()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N):<br>            velocity[i]+=dt/<span class="hljs-number">2</span>*Force[i]/m[i]<br>            KE+=m[i]*<span class="hljs-built_in">sum</span>(velocity[i]*velocity[i])<br>    T=KE/(<span class="hljs-number">3</span>*N*k)<br>    G[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>*N*k*(T-T0)<br>    KE*=<span class="hljs-number">0.5</span>   <br></code></pre></td></tr></table></figure><h1 id="力与势能的计算">力与势能的计算</h1><ul><li>Lennard-Jones Potential</li></ul><p><span class="math display">\[U^{LJ}(r_{ij})=4\epsilon\bigl(\frac{\sigma^{12}}{r_{ij}^{12}}-\frac{\sigma^6}{r_{ij}^6}\bigr)\\r_{ij}=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}\]</span></p><p>Force <span class="math display">\[Fx_i=-\frac{\partial U^{LJ}(r_{ij})}{\partial x_i}=4\epsilon\bigl(\frac{12\sigma^{12}}{r_{ij}^{13}}-\frac{6\sigma^6}{r_{ij}^7}\bigr)\cdot\frac{x_i}{r_{ij}}\]</span> Extreme point <span class="math display">\[r_m=\sqrt[6]{2}\,\sigma\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>plt.figure(dpi=<span class="hljs-number">100</span>)<br>r=np.linspace(<span class="hljs-number">0.3</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">1000</span>)<br>u12=<span class="hljs-number">4</span>*(<span class="hljs-number">0.3405</span>/r)**<span class="hljs-number">12</span><br>u6=-<span class="hljs-number">4</span>*(<span class="hljs-number">0.3405</span>/r)**<span class="hljs-number">6</span><br>u=u12+u6<br>plt.xlabel(<span class="hljs-string">&quot;r/nm&quot;</span>)<br>plt.xlim(<span class="hljs-number">0</span>,<span class="hljs-number">1.5</span>)<br>plt.ylabel(<span class="hljs-string">&quot;U(r)/(kJ/mol)&quot;</span>)<br>plt.ylim([-<span class="hljs-number">1.5</span>,<span class="hljs-number">1.5</span>])<br>plt.plot(r,u12,label=<span class="hljs-string">&quot;r12 repulsive potential&quot;</span>)<br>plt.plot(r,u6,label=<span class="hljs-string">&quot;r6 attractive potential&quot;</span>)<br>plt.plot(r,u,label=<span class="hljs-string">&quot;Lennard-Jones potential&quot;</span>)<br>plt.text(<span class="hljs-number">0.51</span>,-<span class="hljs-number">1</span>,<span class="hljs-string">&quot;r$_m$=&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0.3405</span>*<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>)))<br>plt.show()<br><br></code></pre></td></tr></table></figure><p><img src="/2024/02/11/LJ-fluid-simulation/image-20250207011425727.png" alt="image-20250207011425727" style="zoom: 80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">LJtopology</span>(<span class="hljs-params">elji,sigmalji,rci</span>):<br>    <span class="hljs-keyword">global</span> sigmalj<br>    <span class="hljs-keyword">global</span> sigmalj6<br>    <span class="hljs-keyword">global</span> elj<br>    <span class="hljs-keyword">global</span> rc2  <span class="hljs-comment"># cutoff  radial</span><br>    <span class="hljs-keyword">global</span> ecut<br>    <br>    elj=elji<br>    sigmalj=sigmalji<br>    rc=rci<br>    rc2=rc*rc<br>    sigmalj6=sigmalj**<span class="hljs-number">6</span><br>    sir=sigmalj6/(rc2**<span class="hljs-number">3</span>)<br>    ecut=<span class="hljs-number">4</span>*elj*sir*(sir-<span class="hljs-number">1</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LJforce</span>():<br>    <span class="hljs-keyword">global</span> Force<br>    <span class="hljs-keyword">global</span> UE<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    simple cutoff sheme, rc &lt;= min(lbox)/2, calculate Force and Potential energy with minimum image convention rule.</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    Force=np.zeros([N,<span class="hljs-number">3</span>])<br>    UE=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> pbc==[]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(i+<span class="hljs-number">1</span>,N):<br>                xr=r[i]-r[j]<br>                r2=<span class="hljs-built_in">sum</span>(xr*xr)<br>                <span class="hljs-keyword">if</span> r2 &lt; rc2:<br>                    r2i=<span class="hljs-number">1</span>/r2<br>                    r6i=r2i**<span class="hljs-number">3</span><br>                    r8i=r6i*r2i<br>                    ff=<span class="hljs-number">48</span>*elj*sigmalj6*r8i*(sigmalj6*r6i-<span class="hljs-number">0.5</span>)*xr<br>                    Force[i]+=ff<br>                    Force[j]+=-ff<br>                    UE+=<span class="hljs-number">4</span>*elj*sigmalj6*r6i*(sigmalj6*r6i-<span class="hljs-number">1</span>)-ecut<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(N-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(i+<span class="hljs-number">1</span>,N):<br>                xr=r[i]-r[j]<br>                xr[<span class="hljs-number">0</span>]=xr[<span class="hljs-number">0</span>]-lxbox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">0</span>]/lxbox)<br>                xr[<span class="hljs-number">1</span>]=xr[<span class="hljs-number">1</span>]-lybox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">1</span>]/lybox)<br>                xr[<span class="hljs-number">2</span>]=xr[<span class="hljs-number">2</span>]-lzbox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">2</span>]/lzbox)<br>                r2=<span class="hljs-built_in">sum</span>(xr*xr)<br>                <span class="hljs-keyword">if</span> r2 &lt; rc2:<br>                    r2i=<span class="hljs-number">1</span>/r2<br>                    r6i=r2i**<span class="hljs-number">3</span><br>                    r8i=r6i*r2i<br>                    ff=<span class="hljs-number">48</span>*elj*sigmalj6*r8i*(sigmalj6*r6i-<span class="hljs-number">0.5</span>)*xr<br>                    Force[i]+=ff<br>                    Force[j]+=-ff<br>                    UE+=<span class="hljs-number">4</span>*elj*sigmalj6*r6i*(sigmalj6*r6i-<span class="hljs-number">1</span>)-ecut  <br></code></pre></td></tr></table></figure><h1 id="参数设置">参数设置</h1><ul><li><p>Simulation parameters: the time step (ps): 0.01 the proportionthat dt/dt(NHC): 20 the number of the simulation steps: 10000 the numberof particles: 216 the target temperature (K): 119.8 the number ofthermostats: 2 the character time scale <span class="math inline">\(\tau\)</span> (ps): 0.2</p></li><li><p>Boundary Condition: cubic box lbox= 2.04 nm</p></li><li><p>Topology: 216 Ar atoms, mass 39.94 g/mol LJ_epsilon: 0.99607kJ/mol LJ_sigma: 0.3405 nm Cutoff radial: 1.0 nm</p></li><li><p>Initialization: positions: put the particles on the cubic latticevelocities: use Box-Miller method sampling the MB distribution at Ti=110K thermostat variables: zeros</p></li><li><p>Dump the T,UE,KE,velocities and positions every step!</p></li></ul><h1 id="code模拟与数据存储">Code：模拟与数据存储</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#setParm(dti, nthermoi, nstepi,Ni, T0i, Mi, taoi)</span><br>setParm(<span class="hljs-number">0.01</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">216</span>, <span class="hljs-number">119.8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.2</span>)<br>setBC()<br>LJtopology(<span class="hljs-number">0.99607</span>, <span class="hljs-number">0.3405</span>, <span class="hljs-number">1.0</span>)<br>mass=<span class="hljs-number">39.94</span><br><span class="hljs-keyword">global</span> m<br>m=np.ones(N)*mass<br><span class="hljs-comment">#初始化</span><br>initial_position()<br>initial_velocity(<span class="hljs-number">110</span>) <br>LJforce()<br>initial_nhc(<span class="hljs-string">&quot;zero&quot;</span>)<br>initial_G()<br><span class="hljs-comment">#模拟</span><br>Ts=np.zeros(nstep+<span class="hljs-number">1</span>)<br>KEs=np.zeros(nstep+<span class="hljs-number">1</span>)<br>UEs=np.zeros(nstep+<span class="hljs-number">1</span>)<br>vstore=np.zeros([nstep+<span class="hljs-number">1</span>,N,<span class="hljs-number">3</span>])<br>xstore=np.zeros([nstep+<span class="hljs-number">1</span>,N,<span class="hljs-number">3</span>])<br>times=np.zeros(nstep+<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simulation start!&quot;</span>)<br><span class="hljs-keyword">global</span> time<br><span class="hljs-keyword">global</span> ncount<br>ncount=<span class="hljs-number">0</span><br>time=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> ncount &lt;= nstep:<br>    Ts[ncount]=T<br>    KEs[ncount]=KE<br>    UEs[ncount]=UE<br>    xstore[ncount]=r<br>    vstore[ncount]=velocity<br>    times[ncount]=time<br>    <span class="hljs-keyword">if</span> ncount%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>([ncount,T,KE,UE])<br>    NHCstep()<br>    time=ncount*dt<br>    ncount=ncount+<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simulation finish!&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Set up the simulation paramatersthe type of periodic boundary condition (e.g. &#39;cubic&#39;,&#39;rectangle&#39;,&#39;noPBC&#39;): cubicthe length of the cubic box (nm): 2.04Simulation start![0, 110, 296.327429244, -789.1019846977582]... ...Simulation finish!</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#dump temperature, kinetic, potential and total energy</span><br>file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./LJsim1_log.txt&quot;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">10001</span>):<br>    file.writelines(<span class="hljs-string">&quot;&#123;nsteps&#125;  &#123;time:.2f&#125;  &#123;T:.14f&#125;  &#123;KE:.14f&#125;  &#123;UE:.14f&#125;  &#123;TE:.14f&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(nsteps=line,time=times[line],T=Ts[line],KE=KEs[line],UE=UEs[line],TE=KEs[line]+UEs[line]))<br>file.close()<br><br>vfile=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./LJsim1_v.txt&quot;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">10001</span>):<br>    vfile.writelines(<span class="hljs-string">&quot;&#123;nsteps&#125;  &#123;time:.2f&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(nsteps=step,time=times[step]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">216</span>):<br>        vfile.writelines(<span class="hljs-string">&quot;&#123;vx&#125;  &#123;vy&#125;  &#123;vz&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(vx=vstore[step,i,<span class="hljs-number">0</span>],vy=vstore[step,i,<span class="hljs-number">1</span>],vz=vstore[step,i,<span class="hljs-number">2</span>]))<br>vfile.close()        <br>xfile=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./LJsim1_x.txt&quot;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">10001</span>):<br>    xfile.writelines(<span class="hljs-string">&quot;&#123;nsteps&#125;  &#123;time:.2f&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(nsteps=step,time=times[step]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">216</span>):<br>        xfile.writelines(<span class="hljs-string">&quot;&#123;xx&#125;  &#123;xy&#125;  &#123;xz&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(xx=xstore[step,i,<span class="hljs-number">0</span>],xy=xstore[step,i,<span class="hljs-number">1</span>],xz=xstore[step,i,<span class="hljs-number">2</span>]))<br>xfile.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用pickle方法读写数据</span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;LJsim1_vstore.pickle&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(vstore, f)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;LJsim1_xstore.pickle&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(xstore,f)<br></code></pre></td></tr></table></figure><h1 id="数据分析与可视化">数据分析与可视化</h1><h2 id="径向分布函数-rdf">径向分布函数 (RDF)</h2><ul><li>原子b对原子a的径向分布函数定义为：</li></ul><p><span class="math display">\[g_{ab}(r)=\frac{P_b(r)}{4\pi\rho_br^2dr}\]</span></p><p>其中<span class="math inline">\(P_b(r)\)</span>是原子b出现在离原子a距离为<span class="math inline">\([r,r+dr)\)</span>的球形壳层中的概率。故径向分布函数就是径向概率密度除以原子b的平均密度，归一化到<span class="math inline">\(N_b\)</span>。在无限远处 <span class="math inline">\(g_{ab}(\infty)=\rho_b\)</span>。实际计算时，首先设定最大距离 <span class="math inline">\(r_{max}(&lt;\frac{1}{2}L_{box})\)</span> 和区间数 <span class="math inline">\(N_r\)</span> 。将 <span class="math inline">\([0,r_{max})\)</span> 分为宽度为<span class="math inline">\(\Delta r=r_{max}/N_r\)</span> 的 <span class="math inline">\(N_r\)</span>个小区间，对轨迹的每一帧、每个a、b原子对，统计距离落在区间 <span class="math inline">\([r_i,r_i+dr)\)</span> 的频数 <span class="math inline">\(h_{ab}(i)\)</span>。可用下式获取小区间的index:<span class="math display">\[i=int(\frac{r}{\Delta r})\]</span> 最终径向分布函数可用下式计算： <span class="math display">\[g_{ab}(r_i)=\frac{h_{ab}(r_i)}{4\pi\rho_br_i^2\Delta rN_{conf}N_a}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#计算RDF</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">RDF</span>(<span class="hljs-params">xtrj,rmax,nr</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    xtrj: trjectory</span><br><span class="hljs-string">    rmax: maximum distance</span><br><span class="hljs-string">    nr: the number of intervals</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    Nconf=<span class="hljs-built_in">len</span>(xtrj)<br>    Na=<span class="hljs-built_in">len</span>(xtrj[<span class="hljs-number">0</span>])<br>    rho=Na/(lxbox*lybox*lzbox)<br>    dr=rmax/nr<br>    disr=np.zeros(nr)<br>    rdf=np.zeros(nr)<br>    <span class="hljs-keyword">for</span> ncg <span class="hljs-keyword">in</span> np.arange(Nconf):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(Na-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> np.arange(i+<span class="hljs-number">1</span>,Na):<br>                xr=xtrj[ncg,i]-xtrj[ncg,j]<br>                xr[<span class="hljs-number">0</span>]=xr[<span class="hljs-number">0</span>]-lxbox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">0</span>]/lxbox)<br>                xr[<span class="hljs-number">1</span>]=xr[<span class="hljs-number">1</span>]-lybox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">1</span>]/lybox)<br>                xr[<span class="hljs-number">2</span>]=xr[<span class="hljs-number">2</span>]-lzbox*<span class="hljs-built_in">round</span>(xr[<span class="hljs-number">2</span>]/lzbox)<br>                dis=sqrt(<span class="hljs-built_in">sum</span>(xr**<span class="hljs-number">2</span>))<br>                <span class="hljs-keyword">if</span> dis &lt;= rmax:<br>                    index=<span class="hljs-built_in">int</span>(dis/dr)<br>                    rdf[index]+=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> jk <span class="hljs-keyword">in</span> np.arange(nr):<br>        disr[jk]=dr*(jk+<span class="hljs-number">0.5</span>)<br>        vb=((jk+<span class="hljs-number">1</span>)**<span class="hljs-number">3</span>-jk**<span class="hljs-number">3</span>)*dr**<span class="hljs-number">3</span><br>        nid=<span class="hljs-number">4</span>/<span class="hljs-number">3</span>*pi*vb*rho<br>        rdf[jk]=rdf[jk]/(Nconf*Na*nid)<br>    <span class="hljs-keyword">return</span> [disr,rdf]<br></code></pre></td></tr></table></figure><h2 id="初始条件">初始条件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D  <span class="hljs-comment"># 空间三维画图</span><br>plt.rcParams[<span class="hljs-string">&quot;font.family&quot;</span>]=[<span class="hljs-string">&#x27;Times New Roman&#x27;</span>]<br>plt.rcParams[<span class="hljs-string">&quot;font.size&quot;</span>]=<span class="hljs-number">15</span><br>data = xstore2[<span class="hljs-number">0</span>]<br>x = data[:, <span class="hljs-number">0</span>]  <br>y = data[:, <span class="hljs-number">1</span>]  <br>z = data[:, <span class="hljs-number">2</span>]  <br>fig = plt.figure()<br>ax = Axes3D(fig)<br>ax.scatter(x, y, z)<br>ax.set_zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>&#125;)<br>ax.set_ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>&#125;)<br>ax.set_xlabel(<span class="hljs-string">&#x27;X&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>&#125;)<br>plt.show()<br>plt.figure(figsize=[<span class="hljs-number">10</span>,<span class="hljs-number">4</span>],dpi=<span class="hljs-number">100</span>)<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.title(<span class="hljs-string">&quot;Intial position&quot;</span>)<br>[dist,rdf]=RDF(xstore2[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>],<span class="hljs-number">1.0</span>,<span class="hljs-number">100</span>)<br>plt.xlabel(<span class="hljs-string">&quot;distance(nm)&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;RDF&quot;</span>)<br>plt.plot(dist,rdf)<br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.hist(np.ravel(vstore2[<span class="hljs-number">0</span>]),bins=<span class="hljs-number">100</span>, density=<span class="hljs-literal">True</span>,label=<span class="hljs-string">&#x27;Simulation&#x27;</span>)<br>plt.title(<span class="hljs-string">&quot;Initial velocity&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;velocity(nm/ps)&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;PDF&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="/2024/02/11/LJ-fluid-simulation/image-20250207011455597.png" alt="image-20250207011455597"><figcaption aria-hidden="true">image-20250207011455597</figcaption></figure><p><img src="/2024/02/11/LJ-fluid-simulation/image-20250207011539956.png" alt="image-20250207011539956" style="zoom:67%;"></p><h2 id="模拟结果">模拟结果</h2><figure><img src="/2024/02/11/LJ-fluid-simulation/image-20250207011604565.png" alt="image-20250207011604565"><figcaption aria-hidden="true">image-20250207011604565</figcaption></figure><ul><li>20 ps 后平均温度稳定在目标温度附近，速度分布与MB分布吻合得很好</li><li>经典离域子体系理想的温度分布为：</li></ul><p><span class="math display">\[f(T)=\frac{1}{\Gamma(\frac{3N+1}{2})}(\frac{3N}{2T_0})^{\frac{3N+1}{2}}\cdotT^{\frac{3N-1}{2}}\cdot exp(-\frac{3N}{2T_0}T)\]</span></p><p>当N很大时，上述分布区域Gauss分布，且变得尖锐。温度的相对涨落满足：<span class="math display">\[\frac{\sigma^2_T}{&lt;T&gt;^2}=\frac{2}{3N}\]</span>由图可见，虽然任一自由度的速度分布与理想分布十分吻合，模拟产生的温度分布相比理想情形过于尖锐。调节热浴质量参数可能使温度涨落更接近理想。</p><ul><li>径向分布函数在LJ势的极小值点附近出现第一个极大值，与实际情况吻合。由于模拟时长较短，曲线不够平滑。最大距离不能超过模拟盒子的一半长度，以免计算粒子与自身镜像的作用，因而此处无法显示1.5 nm 附近RDF趋于1的情况。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline <br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gamma<br>nstep=<span class="hljs-number">10000</span><br>plt.rcParams[<span class="hljs-string">&quot;font.family&quot;</span>]=[<span class="hljs-string">&#x27;Times New Roman&#x27;</span>]<br>plt.rcParams[<span class="hljs-string">&quot;font.size&quot;</span>]=<span class="hljs-number">20</span><br><span class="hljs-comment">#分析1.温度随时间的变化</span><br>plt.figure(figsize=[<span class="hljs-number">16</span>,<span class="hljs-number">16</span>],dpi=<span class="hljs-number">150</span>)<br>plt.subplot(<span class="hljs-number">221</span>)<br>plt.xlabel(<span class="hljs-string">&quot;time&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Temperature(K)&quot;</span>)<br>avT=np.zeros(nstep+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> np.arange(nstep+<span class="hljs-number">1</span>):<br>    avT[n]=<span class="hljs-built_in">sum</span>(Ts[<span class="hljs-number">0</span>:n+<span class="hljs-number">1</span>])/(n+<span class="hljs-number">1</span>)<br>plt.scatter(times,Ts,label=<span class="hljs-string">&quot;Instantious Temperature&quot;</span>,marker=<span class="hljs-string">&#x27;p&#x27;</span>,alpha=<span class="hljs-number">0.5</span>,s=<span class="hljs-number">0.1</span>)<br>plt.plot(times,avT,label=<span class="hljs-string">&quot;Average Temperature&quot;</span>,color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.scatter(times[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">20</span>],T0*np.ones(nstep+<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>:nstep:<span class="hljs-number">20</span>],label=<span class="hljs-string">&quot;Target Temperature&quot;</span>,s=<span class="hljs-number">5</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.legend()<br><span class="hljs-comment">#分析2.温度的分布，与理想的平衡分布比较</span><br>plt.subplot(<span class="hljs-number">222</span>)<br>plt.hist(Ts,bins=<span class="hljs-number">200</span>,density=<span class="hljs-literal">True</span>,label=<span class="hljs-string">&#x27;Simulation&#x27;</span>)<br>tx=np.linspace(<span class="hljs-number">100</span>,<span class="hljs-number">140</span>,<span class="hljs-number">100</span>)<br><br>te=np.power(<span class="hljs-number">3</span>*N/(<span class="hljs-number">2</span>*pi*T0*tx),<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0.5</span>*<span class="hljs-number">3</span>*N):<br>    te*=<span class="hljs-number">3</span>*N*tx/<span class="hljs-number">2</span>/T0*np.exp(-tx/T0)/(<span class="hljs-number">0.5</span>+i)<br><br>plt.plot(tx,te,label=<span class="hljs-string">&#x27;Exact&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Temperature(K)&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;PDF&quot;</span>)<br>plt.legend()<br><span class="hljs-comment">#分析3.速度的分布,与理想的平衡分布（高斯分布）比较</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;LJsim1_vstore.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    vstore2 = pickle.load(f)<br>plt.subplot(<span class="hljs-number">223</span>)<br>plt.xlabel(<span class="hljs-string">&quot;velocity(nm/ps)&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;PDF&quot;</span>)<br>plt.hist(np.ravel(vstore2),bins=<span class="hljs-number">100</span>, density=<span class="hljs-literal">True</span>,label=<span class="hljs-string">&#x27;Simulation&#x27;</span>)<br>vx=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>ve=sqrt(m[<span class="hljs-number">0</span>]/(<span class="hljs-number">2</span>*pi*k*T0))*np.exp(-<span class="hljs-number">0.5</span>*m[<span class="hljs-number">0</span>]*vx**<span class="hljs-number">2</span>/k/T0)<br>plt.plot(vx,ve,label=<span class="hljs-string">&#x27;Exact&#x27;</span>)<br>plt.legend(loc=<span class="hljs-string">&#x27;upper right&#x27;</span>)<br><span class="hljs-comment">#分析4：径向分布函数</span><br>plt.subplot(<span class="hljs-number">224</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;LJsim1_xstore.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    xstore2 = pickle.load(f)<br><span class="hljs-comment">#RDF(xtrj,rmax,nr)</span><br>[disr,rdf]=RDF(xstore2[<span class="hljs-number">0</span>:<span class="hljs-number">10001</span>:<span class="hljs-number">10</span>],<span class="hljs-number">1.0</span>,<span class="hljs-number">100</span>)<br><br>plt.xlabel(<span class="hljs-string">&quot;distance(nm)&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;RDF&quot;</span>)<br>plt.plot(disr,rdf)<br><br>plt.show()<br></code></pre></td></tr></table></figure><h1 id="参考文献">参考文献</h1><ol type="1"><li><p>Mark E. Tuckerman. (2010). Statistical Mechanics: Theory andMolecular Simulation. Oxford: Oxford University Press.</p></li><li><p>Daan Frenkel &amp; Berend Smit著, 汪文川译. (2002).分子模拟:从算法到应用. 化学工业出版社.</p></li></ol><p>​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Science</category>
      
      <category>Computational Chemistry</category>
      
      <category>Molecular Dynamics</category>
      
      <category>Statistical Mechanics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Molecular Dynamics</tag>
      
      <tag>Statistical Mechanics</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
